{"version":3,"file":"useForceUpdate.js","sourceRoot":"","sources":["../../src/hooks/useForceUpdate.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,+BAAqD;AACrD,qDAAmD;AACnD,+CAA6C;AAE7C,IAAM,WAAW,GAAU,EAAE,CAAA;AAC7B,IAAM,YAAY,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,CAAA;AACjC,IAAM,YAAY,GAAG,IAAI,GAAG,EAAc,CAAA;AAE1C,SAAgB,cAAc;IACtB,IAAA,KAAA,OAAe,IAAA,gBAAQ,EAAC,EAAE,CAAC,IAAA,EAAxB,QAAQ,QAAgB,CAAA;IACjC,IAAM,WAAW,GAAG,IAAA,cAAM,EAAC,KAAK,CAAC,CAAA;IACjC,IAAA,iCAAe,EAAC;QACd,WAAW,CAAC,OAAO,GAAG,IAAI,CAAA;QAC1B,OAAO;YACL,WAAW,CAAC,OAAO,GAAG,KAAK,CAAA;QAC7B,CAAC,CAAA;IACH,CAAC,EAAE,WAAW,CAAC,CAAA;IAEf,IAAM,MAAM,GAAG,IAAA,mBAAW,EAAC;QACzB,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE;YACxB,+CAA+C;YAC/C,mDAAmD;YACnD,OAAM;SACP;QACD,QAAQ,CAAC,EAAE,CAAC,CAAA;IACd,CAAC,EAAE,WAAW,CAAC,CAAA;IAEf,IAAM,SAAS,GAAG,IAAA,mBAAW,EAAC;QAC5B,IAAI,YAAY,CAAC,KAAK,KAAK,CAAC,EAAE;YAC5B,MAAM,EAAE,CAAA;SACT;aAAM;YACL,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;SACzB;IACH,CAAC,EAAE,WAAW,CAAC,CAAA;IAEf,YAAY,CAAC,KAAK,EAAE,CAAA;IAEpB,IAAA,2BAAY,EAAC;QACX,IAAI,YAAY,CAAC,KAAK,GAAG,CAAC,EAAE;YAC1B,YAAY,CAAC,KAAK,EAAE,CAAA;SACrB;QACD,IAAI,YAAY,CAAC,KAAK,KAAK,CAAC,EAAE;YAC5B,YAAY,CAAC,OAAO,CAAC,UAAC,MAAM;gBAC1B,YAAY,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;gBAC3B,MAAM,EAAE,CAAA;YACV,CAAC,CAAC,CAAA;SACH;IACH,CAAC,CAAC,CAAA;IAEF,OAAO,SAAS,CAAA;AAClB,CAAC;AA1CD,wCA0CC","sourcesContent":["import { useCallback, useRef, useState } from 'react'\nimport { useLayoutEffect } from './useLayoutEffect'\nimport { useDidUpdate } from './useDidUpdate'\n\nconst EMPTY_ARRAY: any[] = []\nconst RENDER_COUNT = { value: 0 }\nconst RENDER_QUEUE = new Set<() => void>()\n\nexport function useForceUpdate() {\n  const [, setState] = useState([])\n  const renderedRef = useRef(false)\n  useLayoutEffect(() => {\n    renderedRef.current = true\n    return () => {\n      renderedRef.current = false\n    }\n  }, EMPTY_ARRAY)\n\n  const update = useCallback(() => {\n    if (!renderedRef.current) {\n      // 针对StrictMode无法快速回收内存，只能考虑拦截第一次渲染函数的setState，\n      // 因为第一次渲染函数的setState会触发第二次渲染函数执行，从而清理掉第二次渲染函数内部的依赖\n      return\n    }\n    setState([])\n  }, EMPTY_ARRAY)\n\n  const scheduler = useCallback(() => {\n    if (RENDER_COUNT.value === 0) {\n      update()\n    } else {\n      RENDER_QUEUE.add(update)\n    }\n  }, EMPTY_ARRAY)\n\n  RENDER_COUNT.value++\n\n  useDidUpdate(() => {\n    if (RENDER_COUNT.value > 0) {\n      RENDER_COUNT.value--\n    }\n    if (RENDER_COUNT.value === 0) {\n      RENDER_QUEUE.forEach((update) => {\n        RENDER_QUEUE.delete(update)\n        update()\n      })\n    }\n  })\n\n  return scheduler\n}\n"]}