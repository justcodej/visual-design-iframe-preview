{"version":3,"file":"formily.react.umd.production.js","sources":["../../json-schema/esm/shared.js","../../json-schema/esm/compiler.js","../../json-schema/esm/transformer.js","../../json-schema/esm/patches.js","../../json-schema/esm/polyfills/SPECIFICATION_1_0.js","../../json-schema/esm/schema.js","../src/hooks/useAttach.ts","../src/shared/context.ts","../src/hooks/useForm.ts","../src/hooks/useField.ts","../src/hooks/useExpressionScope.ts","../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js","../src/components/FormProvider.tsx","../src/components/FormConsumer.tsx","../src/components/ReactiveField.tsx","../src/components/ArrayField.tsx","../src/components/ObjectField.tsx","../src/components/VoidField.tsx","../src/components/Field.tsx","../src/components/RecursionField.tsx","../src/components/ExpressionScope.tsx","../src/shared/render.ts","../src/components/SchemaField.tsx","../src/components/RecordScope.tsx","../src/components/RecordsScope.tsx","../src/shared/connect.ts","../src/hooks/useFieldSchema.ts","../src/hooks/useFormEffects.ts","../src/hooks/useParentForm.ts"],"sourcesContent":["import { isFn, each, isPlainObj, isArr, toArr, FormPath } from '@formily/shared';\nimport { isObservable, untracked } from '@formily/reactive';\nimport { Schema } from './schema';\nvar REVA_ACTIONS_KEY = Symbol.for('__REVA_ACTIONS');\nexport var SchemaNestedMap = {\n    parent: true,\n    root: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    items: true,\n    additionalItems: true,\n    'x-linkages': true,\n    'x-reactions': true,\n};\nexport var SchemaStateMap = {\n    title: 'title',\n    description: 'description',\n    default: 'initialValue',\n    enum: 'dataSource',\n    readOnly: 'readOnly',\n    writeOnly: 'editable',\n    'x-content': 'content',\n    'x-data': 'data',\n    'x-value': 'value',\n    'x-editable': 'editable',\n    'x-disabled': 'disabled',\n    'x-read-pretty': 'readPretty',\n    'x-read-only': 'readOnly',\n    'x-visible': 'visible',\n    'x-hidden': 'hidden',\n    'x-display': 'display',\n    'x-pattern': 'pattern',\n    'x-validator': 'validator',\n    'x-decorator': 'decoratorType',\n    'x-component': 'componentType',\n    'x-decorator-props': 'decoratorProps',\n    'x-component-props': 'componentProps',\n};\nexport var SchemaValidatorMap = {\n    required: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    maxLength: true,\n    minLength: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    pattern: true,\n    const: true,\n    multipleOf: true,\n    maxProperties: true,\n    minProperties: true,\n    uniqueItems: true,\n};\nexport var SchemaNormalKeys = Object.keys(SchemaStateMap);\nexport var SchemaValidatorKeys = Object.keys(SchemaValidatorMap);\nexport var hasOwnProperty = Object.prototype.hasOwnProperty;\nexport var traverse = function (target, visitor) {\n    var seenObjects = [];\n    var root = target;\n    var traverse = function (target, path) {\n        if (path === void 0) { path = []; }\n        if (isPlainObj(target)) {\n            var seenIndex = seenObjects.indexOf(target);\n            if (seenIndex > -1) {\n                return;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(target);\n            if (isNoNeedCompileObject(target) && root !== target) {\n                visitor(target, path);\n                return;\n            }\n            each(target, function (value, key) {\n                traverse(value, path.concat(key));\n            });\n            seenObjects.splice(addIndex, 1);\n        }\n        else {\n            visitor(target, path);\n        }\n    };\n    traverse(target);\n};\nexport var traverseSchema = function (schema, visitor) {\n    if (schema['x-validator'] !== undefined) {\n        visitor(schema['x-validator'], ['x-validator']);\n    }\n    var seenObjects = [];\n    var root = schema;\n    var traverse = function (target, path) {\n        var _a;\n        if (path === void 0) { path = []; }\n        if (path[0] === 'x-compile-omitted' ||\n            path[0] === 'x-validator' ||\n            path[0] === 'version' ||\n            path[0] === '_isJSONSchemaObject')\n            return;\n        if (String(path[0]).indexOf('x-') == -1 && isFn(target))\n            return;\n        if (SchemaNestedMap[path[0]])\n            return;\n        if (((_a = schema['x-compile-omitted']) === null || _a === void 0 ? void 0 : _a.indexOf(path[0])) > -1) {\n            visitor(target, path, true);\n            return;\n        }\n        if (isPlainObj(target)) {\n            if (path[0] === 'default' || path[0] === 'x-value') {\n                visitor(target, path);\n                return;\n            }\n            var seenIndex = seenObjects.indexOf(target);\n            if (seenIndex > -1) {\n                return;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(target);\n            if (isNoNeedCompileObject(target) && root !== target) {\n                visitor(target, path);\n                return;\n            }\n            each(target, function (value, key) {\n                traverse(value, path.concat(key));\n            });\n            seenObjects.splice(addIndex, 1);\n        }\n        else {\n            visitor(target, path);\n        }\n    };\n    traverse(schema);\n};\nexport var isNoNeedCompileObject = function (source) {\n    if ('$$typeof' in source && '_owner' in source) {\n        return true;\n    }\n    if (source['_isAMomentObject']) {\n        return true;\n    }\n    if (Schema.isSchemaInstance(source)) {\n        return true;\n    }\n    if (source[REVA_ACTIONS_KEY]) {\n        return true;\n    }\n    if (isFn(source['toJS'])) {\n        return true;\n    }\n    if (isFn(source['toJSON'])) {\n        return true;\n    }\n    if (isObservable(source)) {\n        return true;\n    }\n    return false;\n};\nexport var createDataSource = function (source) {\n    return toArr(source).map(function (item) {\n        if (typeof item === 'object') {\n            return item;\n        }\n        else {\n            return {\n                label: item,\n                value: item,\n            };\n        }\n    });\n};\nexport var patchStateFormSchema = function (targetState, pattern, compiled) {\n    untracked(function () {\n        var _a;\n        var path = FormPath.parse(pattern);\n        var segments = path.segments;\n        var key = segments[0];\n        var isEnum = key === 'enum' && isArr(compiled);\n        var schemaMapKey = SchemaStateMap[key];\n        if (schemaMapKey) {\n            FormPath.setIn(targetState, [schemaMapKey].concat(segments.slice(1)), isEnum ? createDataSource(compiled) : compiled);\n        }\n        else {\n            var isValidatorKey = SchemaValidatorMap[key];\n            if (isValidatorKey) {\n                (_a = targetState['setValidatorRule']) === null || _a === void 0 ? void 0 : _a.call(targetState, key, compiled);\n            }\n        }\n    });\n};\n//# sourceMappingURL=shared.js.map","import { isArr, isFn, isPlainObj, isStr, reduce, FormPath, } from '@formily/shared';\nimport { untracked, hasCollected } from '@formily/reactive';\nimport { traverse, traverseSchema, isNoNeedCompileObject, hasOwnProperty, patchStateFormSchema, } from './shared';\nvar ExpRE = /^\\s*\\{\\{([\\s\\S]*)\\}\\}\\s*$/;\nvar Registry = {\n    silent: false,\n    compile: function (expression, scope) {\n        if (scope === void 0) { scope = {}; }\n        if (Registry.silent) {\n            try {\n                return new Function('$root', \"with($root) { return (\".concat(expression, \"); }\"))(scope);\n            }\n            catch (_a) { }\n        }\n        else {\n            return new Function('$root', \"with($root) { return (\".concat(expression, \"); }\"))(scope);\n        }\n    },\n};\nexport var silent = function (value) {\n    if (value === void 0) { value = true; }\n    Registry.silent = !!value;\n};\nexport var registerCompiler = function (compiler) {\n    if (isFn(compiler)) {\n        Registry.compile = compiler;\n    }\n};\nexport var shallowCompile = function (source, scope) {\n    if (isStr(source)) {\n        var matched = source.match(ExpRE);\n        if (!matched)\n            return source;\n        return Registry.compile(matched[1], scope);\n    }\n    return source;\n};\nexport var compile = function (source, scope) {\n    var seenObjects = [];\n    var compile = function (source) {\n        if (isStr(source)) {\n            return shallowCompile(source, scope);\n        }\n        else if (isArr(source)) {\n            return source.map(function (value) { return compile(value); });\n        }\n        else if (isPlainObj(source)) {\n            if (isNoNeedCompileObject(source))\n                return source;\n            var seenIndex = seenObjects.indexOf(source);\n            if (seenIndex > -1) {\n                return source;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(source);\n            var results = reduce(source, function (buf, value, key) {\n                buf[key] = compile(value);\n                return buf;\n            }, {});\n            seenObjects.splice(addIndex, 1);\n            return results;\n        }\n        return source;\n    };\n    return compile(source);\n};\nexport var patchCompile = function (targetState, sourceState, scope) {\n    traverse(sourceState, function (value, pattern) {\n        var path = FormPath.parse(pattern);\n        var compiled = compile(value, scope);\n        var key = path.segments[0];\n        if (compiled === undefined)\n            return;\n        if (hasOwnProperty.call(targetState, key)) {\n            untracked(function () { return FormPath.setIn(targetState, path, compiled); });\n        }\n    });\n};\nexport var patchSchemaCompile = function (targetState, sourceSchema, scope, demand) {\n    if (demand === void 0) { demand = false; }\n    traverseSchema(sourceSchema, function (value, path, omitCompile) {\n        var compiled = value;\n        var collected = hasCollected(function () {\n            if (!omitCompile) {\n                compiled = compile(value, scope);\n            }\n        });\n        if (compiled === undefined)\n            return;\n        if (demand) {\n            if (collected || !targetState.initialized) {\n                patchStateFormSchema(targetState, path, compiled);\n            }\n        }\n        else {\n            patchStateFormSchema(targetState, path, compiled);\n        }\n    });\n};\n//# sourceMappingURL=compiler.js.map","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { untracked, autorun, observable } from '@formily/reactive';\nimport { isArr, isStr, toArr, each, isFn, isPlainObj, reduce, lazyMerge, } from '@formily/shared';\nimport { onFieldInit, onFieldMount, onFieldUnmount, onFieldValueChange, onFieldInputValueChange, onFieldInitialValueChange, onFieldValidateStart, onFieldValidateEnd, onFieldValidateFailed, onFieldValidateSuccess, } from '@formily/core';\nimport { patchCompile, patchSchemaCompile, shallowCompile } from './compiler';\nvar FieldEffects = {\n    onFieldInit: onFieldInit,\n    onFieldMount: onFieldMount,\n    onFieldUnmount: onFieldUnmount,\n    onFieldValueChange: onFieldValueChange,\n    onFieldInputValueChange: onFieldInputValueChange,\n    onFieldInitialValueChange: onFieldInitialValueChange,\n    onFieldValidateStart: onFieldValidateStart,\n    onFieldValidateEnd: onFieldValidateEnd,\n    onFieldValidateFailed: onFieldValidateFailed,\n    onFieldValidateSuccess: onFieldValidateSuccess,\n};\nvar DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange'];\nvar getDependencyValue = function (field, pattern, property) {\n    var _a = __read(String(pattern).split(/\\s*#\\s*/), 2), target = _a[0], path = _a[1];\n    return field.query(target).getIn(path || property || 'value');\n};\nvar getDependencies = function (field, dependencies) {\n    if (isArr(dependencies)) {\n        var results_1 = [];\n        dependencies.forEach(function (pattern) {\n            if (isStr(pattern)) {\n                results_1.push(getDependencyValue(field, pattern));\n            }\n            else if (isPlainObj(pattern)) {\n                if (pattern.name && pattern.source) {\n                    results_1[pattern.name] = getDependencyValue(field, pattern.source, pattern.property);\n                }\n            }\n        });\n        return results_1;\n    }\n    else if (isPlainObj(dependencies)) {\n        return reduce(dependencies, function (buf, pattern, key) {\n            buf[key] = getDependencyValue(field, pattern);\n            return buf;\n        }, {});\n    }\n    return [];\n};\nvar setSchemaFieldState = function (options, demand) {\n    if (demand === void 0) { demand = false; }\n    var _a = options || {}, request = _a.request, target = _a.target, runner = _a.runner, field = _a.field, scope = _a.scope;\n    if (!request)\n        return;\n    if (target) {\n        if (request.state) {\n            field.form.setFieldState(target, function (state) {\n                return patchCompile(state, request.state, lazyMerge(scope, {\n                    $target: state,\n                }));\n            });\n        }\n        if (request.schema) {\n            field.form.setFieldState(target, function (state) {\n                return patchSchemaCompile(state, request.schema, lazyMerge(scope, {\n                    $target: state,\n                }), demand);\n            });\n        }\n        if (isStr(runner) && runner) {\n            field.form.setFieldState(target, function (state) {\n                shallowCompile(\"{{function(){\".concat(runner, \"}}}\"), lazyMerge(scope, {\n                    $target: state,\n                }))();\n            });\n        }\n    }\n    else {\n        if (request.state) {\n            field.setState(function (state) { return patchCompile(state, request.state, scope); });\n        }\n        if (request.schema) {\n            field.setState(function (state) {\n                return patchSchemaCompile(state, request.schema, scope, demand);\n            });\n        }\n        if (isStr(runner) && runner) {\n            shallowCompile(\"{{function(){\".concat(runner, \"}}}\"), scope)();\n        }\n    }\n};\nvar getBaseScope = function (field, options) {\n    if (options === void 0) { options = {}; }\n    var $observable = function (target, deps) {\n        return autorun.memo(function () { return observable(target); }, deps);\n    };\n    var $props = function (props) { return field.setComponentProps(props); };\n    var $effect = autorun.effect;\n    var $memo = autorun.memo;\n    var $self = field;\n    var $form = field.form;\n    var $values = field.form.values;\n    return lazyMerge(options.scope, {\n        $form: $form,\n        $self: $self,\n        $observable: $observable,\n        $effect: $effect,\n        $memo: $memo,\n        $props: $props,\n        $values: $values,\n    });\n};\nvar getBaseReactions = function (schema, options) { return function (field) {\n    setSchemaFieldState({\n        field: field,\n        request: { schema: schema },\n        scope: getBaseScope(field, options),\n    }, true);\n}; };\nvar getUserReactions = function (schema, options) {\n    var reactions = toArr(schema['x-reactions']);\n    return reactions.map(function (unCompiled) {\n        return function (field) {\n            var baseScope = getBaseScope(field, options);\n            var reaction = shallowCompile(unCompiled, baseScope);\n            if (!reaction)\n                return;\n            if (isFn(reaction)) {\n                return reaction(field, baseScope);\n            }\n            var when = reaction.when, fulfill = reaction.fulfill, otherwise = reaction.otherwise, target = reaction.target, effects = reaction.effects;\n            var run = function () {\n                var $deps = getDependencies(field, reaction.dependencies);\n                var $dependencies = $deps;\n                var scope = lazyMerge(baseScope, {\n                    $target: null,\n                    $deps: $deps,\n                    $dependencies: $dependencies,\n                });\n                var compiledWhen = shallowCompile(when, scope);\n                var condition = when ? compiledWhen : true;\n                var request = condition ? fulfill : otherwise;\n                var runner = condition ? fulfill === null || fulfill === void 0 ? void 0 : fulfill.run : otherwise === null || otherwise === void 0 ? void 0 : otherwise.run;\n                setSchemaFieldState({\n                    field: field,\n                    target: target,\n                    request: request,\n                    runner: runner,\n                    scope: scope,\n                });\n            };\n            if (target) {\n                reaction.effects = (effects === null || effects === void 0 ? void 0 : effects.length) ? effects : DefaultFieldEffects;\n            }\n            if (reaction.effects) {\n                autorun.memo(function () {\n                    untracked(function () {\n                        each(reaction.effects, function (type) {\n                            if (FieldEffects[type]) {\n                                FieldEffects[type](field.address, run);\n                            }\n                        });\n                    });\n                }, []);\n            }\n            else {\n                run();\n            }\n        };\n    });\n};\nexport var transformFieldProps = function (schema, options) {\n    return {\n        name: schema.name,\n        reactions: [getBaseReactions(schema, options)].concat(getUserReactions(schema, options)),\n    };\n};\n//# sourceMappingURL=transformer.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { isFn, isArr } from '@formily/shared';\nvar patches = [];\nvar polyfills = {};\nexport var reducePatches = function (schema) {\n    return patches.reduce(function (buf, patch) {\n        return patch(buf);\n    }, __assign({}, schema));\n};\nexport var registerPatches = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    args.forEach(function (patch) {\n        if (isFn(patch)) {\n            patches.push(patch);\n        }\n    });\n};\nexport var registerPolyfills = function (version, patch) {\n    if (version && isFn(patch)) {\n        polyfills[version] = polyfills[version] || [];\n        polyfills[version].push(patch);\n    }\n};\nexport var enablePolyfills = function (versions) {\n    if (isArr(versions)) {\n        versions.forEach(function (version) {\n            if (isArr(polyfills[version])) {\n                polyfills[version].forEach(function (patch) {\n                    registerPatches(patch);\n                });\n            }\n        });\n    }\n};\n//# sourceMappingURL=patches.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { registerPolyfills } from '../patches';\nimport { toArr, isArr, isStr, lowerCase, isValid } from '@formily/shared';\nvar VOID_COMPONENTS = [\n    'card',\n    'block',\n    'grid-col',\n    'grid-row',\n    'grid',\n    'layout',\n    'step',\n    'tab',\n    'text-box',\n];\nvar TYPE_DEFAULT_COMPONENTS = {};\nvar transformCondition = function (condition) {\n    if (isStr(condition)) {\n        return condition.replace(/\\$value/, '$self.value');\n    }\n};\nvar transformXLinkage = function (linkages) {\n    if (isArr(linkages)) {\n        return linkages.reduce(function (buf, item) {\n            if (!item)\n                return buf;\n            if (item.type === 'value:visible') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        state: {\n                            visible: true,\n                        },\n                    },\n                    otherwise: {\n                        state: {\n                            visible: false,\n                        },\n                    },\n                });\n            }\n            else if (item.type === 'value:schema') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        schema: SpecificationV1Polyfill(__assign({ version: '1.0' }, item.schema)),\n                    },\n                    otherwise: {\n                        schema: SpecificationV1Polyfill(__assign({ version: '1.0' }, item.otherwise)),\n                    },\n                });\n            }\n            else if (item.type === 'value:state') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        state: item.state,\n                    },\n                    otherwise: {\n                        state: item.otherwise,\n                    },\n                });\n            }\n        }, []);\n    }\n    return [];\n};\nvar SpecificationV1Polyfill = function (schema) {\n    if (isValid(schema['editable'])) {\n        schema['x-editable'] = schema['x-editable'] || schema['editable'];\n        delete schema['editable'];\n    }\n    if (isValid(schema['visible'])) {\n        schema['x-visible'] = schema['x-visible'] || schema['visible'];\n        delete schema['visible'];\n    }\n    if (isValid(schema['display'])) {\n        schema['x-display'] =\n            schema['x-display'] || (schema['display'] ? 'visible' : 'hidden');\n        delete schema['display'];\n    }\n    if (isValid(schema['x-props'])) {\n        schema['x-decorator-props'] =\n            schema['x-decorator-props'] || schema['x-props'];\n        delete schema['display'];\n    }\n    if (schema['x-linkages']) {\n        schema['x-reactions'] = toArr(schema['x-reactions']).concat(transformXLinkage(schema['x-linkages']));\n        delete schema['x-linkages'];\n    }\n    if (schema['x-component']) {\n        if (VOID_COMPONENTS.some(function (component) { return lowerCase(component) === lowerCase(schema['x-component']); })) {\n            schema['type'] = 'void';\n        }\n    }\n    else {\n        if (TYPE_DEFAULT_COMPONENTS[schema['type']]) {\n            schema['x-component'] = TYPE_DEFAULT_COMPONENTS[schema['type']];\n        }\n    }\n    if (!schema['x-decorator'] &&\n        schema['type'] !== 'void' &&\n        schema['type'] !== 'object') {\n        schema['x-decorator'] = schema['x-decorator'] || 'FormItem';\n    }\n    if (schema['x-rules']) {\n        schema['x-validator'] = []\n            .concat(schema['x-validator'] || [])\n            .concat(schema['x-rules']);\n    }\n    return schema;\n};\nregisterPolyfills('1.0', SpecificationV1Polyfill);\nexport var registerVoidComponents = function (components) {\n    VOID_COMPONENTS.push.apply(VOID_COMPONENTS, __spreadArray([], __read(components), false));\n};\nexport var registerTypeDefaultComponents = function (maps) {\n    Object.assign(TYPE_DEFAULT_COMPONENTS, maps);\n};\n//# sourceMappingURL=SPECIFICATION_1_0.js.map","import { map, each, isFn, instOf, FormPath, isStr } from '@formily/shared';\nimport { compile, silent, shallowCompile, registerCompiler } from './compiler';\nimport { transformFieldProps } from './transformer';\nimport { reducePatches, registerPatches, registerPolyfills, enablePolyfills, } from './patches';\nimport { registerVoidComponents, registerTypeDefaultComponents, } from './polyfills';\nimport { SchemaNestedMap } from './shared';\nvar Schema = /** @class */ (function () {\n    function Schema(json, parent) {\n        var _this = this;\n        this._isJSONSchemaObject = true;\n        this.version = '2.0';\n        this.addProperty = function (key, schema) {\n            _this.properties = _this.properties || {};\n            _this.properties[key] = new Schema(schema, _this);\n            _this.properties[key].name = key;\n            return _this.properties[key];\n        };\n        this.removeProperty = function (key) {\n            var schema = _this.properties[key];\n            delete _this.properties[key];\n            return schema;\n        };\n        this.setProperties = function (properties) {\n            for (var key in properties) {\n                _this.addProperty(key, properties[key]);\n            }\n            return _this;\n        };\n        this.addPatternProperty = function (key, schema) {\n            if (!schema)\n                return;\n            _this.patternProperties = _this.patternProperties || {};\n            _this.patternProperties[key] = new Schema(schema, _this);\n            _this.patternProperties[key].name = key;\n            return _this.patternProperties[key];\n        };\n        this.removePatternProperty = function (key) {\n            var schema = _this.patternProperties[key];\n            delete _this.patternProperties[key];\n            return schema;\n        };\n        this.setPatternProperties = function (properties) {\n            if (!properties)\n                return _this;\n            for (var key in properties) {\n                _this.addPatternProperty(key, properties[key]);\n            }\n            return _this;\n        };\n        this.setAdditionalProperties = function (properties) {\n            if (!properties)\n                return;\n            _this.additionalProperties = new Schema(properties);\n            return _this.additionalProperties;\n        };\n        this.setItems = function (schema) {\n            if (!schema)\n                return;\n            if (Array.isArray(schema)) {\n                _this.items = schema.map(function (item) { return new Schema(item, _this); });\n            }\n            else {\n                _this.items = new Schema(schema, _this);\n            }\n            return _this.items;\n        };\n        this.setAdditionalItems = function (items) {\n            if (!items)\n                return;\n            _this.additionalItems = new Schema(items, _this);\n            return _this.additionalItems;\n        };\n        this.findDefinitions = function (ref) {\n            if (!ref || !_this.root || !isStr(ref))\n                return;\n            if (ref.indexOf('#/') !== 0)\n                return;\n            return FormPath.getIn(_this.root, ref.substring(2).split('/'));\n        };\n        this.mapProperties = function (callback) {\n            return Schema.getOrderProperties(_this).map(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                return callback(schema, key, index);\n            });\n        };\n        this.mapPatternProperties = function (callback) {\n            return Schema.getOrderProperties(_this, 'patternProperties').map(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                return callback(schema, key, index);\n            });\n        };\n        this.reduceProperties = function (callback, predicate) {\n            var results = predicate;\n            Schema.getOrderProperties(_this, 'properties').forEach(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                results = callback(results, schema, key, index);\n            });\n            return results;\n        };\n        this.reducePatternProperties = function (callback, predicate) {\n            var results = predicate;\n            Schema.getOrderProperties(_this, 'patternProperties').forEach(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                results = callback(results, schema, key, index);\n            });\n            return results;\n        };\n        this.compile = function (scope) {\n            var schema = new Schema({}, _this.parent);\n            each(_this, function (value, key) {\n                if (isFn(value) && !key.includes('x-'))\n                    return;\n                if (key === 'parent' || key === 'root')\n                    return;\n                if (!SchemaNestedMap[key]) {\n                    schema[key] = value ? compile(value, scope) : value;\n                }\n                else {\n                    schema[key] = value ? shallowCompile(value, scope) : value;\n                }\n            });\n            return schema;\n        };\n        this.fromJSON = function (json) {\n            if (!json)\n                return _this;\n            if (Schema.isSchemaInstance(json))\n                return json;\n            each(reducePatches(json), function (value, key) {\n                if (isFn(value) && !key.includes('x-'))\n                    return;\n                if (key === 'properties') {\n                    _this.setProperties(value);\n                }\n                else if (key === 'patternProperties') {\n                    _this.setPatternProperties(value);\n                }\n                else if (key === 'additionalProperties') {\n                    _this.setAdditionalProperties(value);\n                }\n                else if (key === 'items') {\n                    _this.setItems(value);\n                }\n                else if (key === 'additionalItems') {\n                    _this.setAdditionalItems(value);\n                }\n                else if (key === '$ref') {\n                    _this.fromJSON(_this.findDefinitions(value));\n                }\n                else {\n                    _this[key] = value;\n                }\n            });\n            return _this;\n        };\n        this.toJSON = function (recursion) {\n            if (recursion === void 0) { recursion = true; }\n            var results = {};\n            each(_this, function (value, key) {\n                var _a, _b;\n                if ((isFn(value) && !key.includes('x-')) ||\n                    key === 'parent' ||\n                    key === 'root')\n                    return;\n                if (key === 'properties' || key === 'patternProperties') {\n                    if (!recursion)\n                        return;\n                    results[key] = map(value, function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });\n                }\n                else if (key === 'additionalProperties' || key === 'additionalItems') {\n                    if (!recursion)\n                        return;\n                    results[key] = (_a = value === null || value === void 0 ? void 0 : value.toJSON) === null || _a === void 0 ? void 0 : _a.call(value);\n                }\n                else if (key === 'items') {\n                    if (!recursion)\n                        return;\n                    if (Array.isArray(value)) {\n                        results[key] = value.map(function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });\n                    }\n                    else {\n                        results[key] = (_b = value === null || value === void 0 ? void 0 : value.toJSON) === null || _b === void 0 ? void 0 : _b.call(value);\n                    }\n                }\n                else {\n                    results[key] = value;\n                }\n            });\n            return results;\n        };\n        this.toFieldProps = function (options) {\n            return transformFieldProps(_this, options);\n        };\n        if (parent) {\n            this.parent = parent;\n            this.root = parent.root;\n        }\n        else {\n            this.root = this;\n        }\n        return this.fromJSON(json);\n    }\n    Schema.getOrderProperties = function (schema, propertiesName) {\n        if (schema === void 0) { schema = {}; }\n        if (propertiesName === void 0) { propertiesName = 'properties'; }\n        var orderProperties = [];\n        var unorderProperties = [];\n        for (var key in schema[propertiesName]) {\n            var item = schema[propertiesName][key];\n            var index = item['x-index'];\n            if (!isNaN(index)) {\n                orderProperties[index] = { schema: item, key: key };\n            }\n            else {\n                unorderProperties.push({ schema: item, key: key });\n            }\n        }\n        return orderProperties.concat(unorderProperties).filter(function (item) { return !!item; });\n    };\n    Schema.compile = function (expression, scope) {\n        return compile(expression, scope);\n    };\n    Schema.shallowCompile = function (expression, scope) {\n        return shallowCompile(expression, scope);\n    };\n    Schema.isSchemaInstance = function (value) {\n        return instOf(value, Schema);\n    };\n    Schema.registerCompiler = registerCompiler;\n    Schema.registerPatches = registerPatches;\n    Schema.registerVoidComponents = registerVoidComponents;\n    Schema.registerTypeDefaultComponents = registerTypeDefaultComponents;\n    Schema.registerPolyfills = registerPolyfills;\n    Schema.enablePolyfills = enablePolyfills;\n    Schema.silent = silent;\n    return Schema;\n}());\nexport { Schema };\n//# sourceMappingURL=schema.js.map","import { unstable_useCompatEffect } from '@formily/reactive-react'\ninterface IRecycleTarget {\n  onMount: () => void\n  onUnmount: () => void\n}\n\nexport const useAttach = <T extends IRecycleTarget>(target: T): T => {\n  unstable_useCompatEffect(() => {\n    target.onMount()\n    return () => target.onUnmount()\n  }, [target])\n  return target\n}\n","import React, { createContext } from 'react'\nimport { Form, GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport {\n  ISchemaFieldReactFactoryOptions,\n  SchemaReactComponents,\n} from '../types'\n\nconst createContextCleaner = <T>(...contexts: React.Context<T>[]) => {\n  return ({ children }) => {\n    return contexts.reduce((buf, ctx) => {\n      return React.createElement(ctx.Provider, { value: undefined }, buf)\n    }, children)\n  }\n}\n\nexport const FormContext = createContext<Form>(null)\nexport const FieldContext = createContext<GeneralField>(null)\nexport const SchemaMarkupContext = createContext<Schema>(null)\nexport const SchemaContext = createContext<Schema>(null)\nexport const SchemaExpressionScopeContext = createContext<any>(null)\nexport const SchemaComponentsContext =\n  createContext<SchemaReactComponents>(null)\nexport const SchemaOptionsContext =\n  createContext<ISchemaFieldReactFactoryOptions>(null)\n\nexport const ContextCleaner = createContextCleaner(\n  FieldContext,\n  SchemaMarkupContext,\n  SchemaContext,\n  SchemaExpressionScopeContext,\n  SchemaComponentsContext,\n  SchemaOptionsContext\n)\n","import { useContext } from 'react'\nimport { Form } from '@formily/core'\nimport { FormContext } from '../shared'\n\nexport const useForm = <T extends object = any>(): Form<T> => {\n  return useContext(FormContext)\n}\n","import { useContext } from 'react'\nimport { GeneralField } from '@formily/core'\nimport { FieldContext } from '../shared'\n\nexport const useField = <T = GeneralField>(): T => {\n  return useContext(FieldContext) as any\n}\n","import { useContext } from 'react'\nimport { SchemaExpressionScopeContext } from '../shared/context'\n\nexport const useExpressionScope = () => useContext(SchemaExpressionScopeContext)\n","'use strict';\n\nvar reactIs = require('react-is');\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n","import React from 'react'\nimport { useAttach } from '../hooks/useAttach'\nimport { FormContext, ContextCleaner } from '../shared'\nimport { IProviderProps, ReactFC } from '../types'\n\nexport const FormProvider: ReactFC<IProviderProps> = (props) => {\n  const form = useAttach(props.form)\n  return (\n    <ContextCleaner>\n      <FormContext.Provider value={form}>{props.children}</FormContext.Provider>\n    </ContextCleaner>\n  )\n}\n\nFormProvider.displayName = 'FormProvider'\n","import React, { Fragment } from 'react'\nimport { isFn } from '@formily/shared'\nimport { observer } from '@formily/reactive-react'\nimport { useForm } from '../hooks'\nimport { IFormSpyProps, ReactFC } from '../types'\n\nexport const FormConsumer: ReactFC<IFormSpyProps> = observer((props) => {\n  const children = isFn(props.children) ? props.children(useForm()) : null\n  return <Fragment>{children}</Fragment>\n})\n\nFormConsumer.displayName = 'FormConsumer'\n","import React, { Fragment, useContext } from 'react'\nimport { toJS } from '@formily/reactive'\nimport { observer } from '@formily/reactive-react'\nimport { FormPath, isFn } from '@formily/shared'\nimport { isVoidField, GeneralField, Form } from '@formily/core'\nimport { SchemaComponentsContext } from '../shared'\nimport { RenderPropsChildren } from '../types'\ninterface IReactiveFieldProps {\n  field: GeneralField\n  children?: RenderPropsChildren<GeneralField>\n}\n\nconst mergeChildren = (\n  children: RenderPropsChildren<GeneralField>,\n  content: React.ReactNode\n) => {\n  if (!children && !content) return\n  if (isFn(children)) return\n  return (\n    <Fragment>\n      {children}\n      {content}\n    </Fragment>\n  )\n}\n\nconst isValidComponent = (target: any) =>\n  target && (typeof target === 'object' || typeof target === 'function')\n\nconst renderChildren = (\n  children: RenderPropsChildren<GeneralField>,\n  field?: GeneralField,\n  form?: Form\n) => (isFn(children) ? children(field, form) : children)\n\nconst ReactiveInternal: React.FC<IReactiveFieldProps> = (props) => {\n  const components = useContext(SchemaComponentsContext)\n  if (!props.field) {\n    return <Fragment>{renderChildren(props.children)}</Fragment>\n  }\n  const field = props.field\n  const content = mergeChildren(\n    renderChildren(props.children, field, field.form),\n    field.content ?? field.componentProps.children\n  )\n  if (field.display !== 'visible') return null\n\n  const getComponent = (target: any) => {\n    return isValidComponent(target)\n      ? target\n      : FormPath.getIn(components, target) ?? target\n  }\n\n  const renderDecorator = (children: React.ReactNode) => {\n    if (!field.decoratorType) {\n      return <Fragment>{children}</Fragment>\n    }\n\n    return React.createElement(\n      getComponent(field.decoratorType),\n      toJS(field.decoratorProps),\n      children\n    )\n  }\n\n  const renderComponent = () => {\n    if (!field.componentType) return content\n    const value = !isVoidField(field) ? field.value : undefined\n    const onChange = !isVoidField(field)\n      ? (...args: any[]) => {\n          field.onInput(...args)\n          field.componentProps?.onChange?.(...args)\n        }\n      : field.componentProps?.onChange\n    const onFocus = !isVoidField(field)\n      ? (...args: any[]) => {\n          field.onFocus(...args)\n          field.componentProps?.onFocus?.(...args)\n        }\n      : field.componentProps?.onFocus\n    const onBlur = !isVoidField(field)\n      ? (...args: any[]) => {\n          field.onBlur(...args)\n          field.componentProps?.onBlur?.(...args)\n        }\n      : field.componentProps?.onBlur\n    const disabled = !isVoidField(field)\n      ? field.pattern === 'disabled' || field.pattern === 'readPretty'\n      : undefined\n    const readOnly = !isVoidField(field)\n      ? field.pattern === 'readOnly'\n      : undefined\n    return React.createElement(\n      getComponent(field.componentType),\n      {\n        disabled,\n        readOnly,\n        ...toJS(field.componentProps),\n        value,\n        onChange,\n        onFocus,\n        onBlur,\n      },\n      content\n    )\n  }\n\n  return renderDecorator(renderComponent())\n}\n\nReactiveInternal.displayName = 'ReactiveField'\n\nexport const ReactiveField = observer(ReactiveInternal, {\n  forwardRef: true,\n})\n","import React from 'react'\nimport { ArrayField as ArrayFieldType } from '@formily/core'\nimport { useForm, useField } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { FieldContext } from '../shared'\nimport { JSXComponent, IFieldProps } from '../types'\nimport { ReactiveField } from './ReactiveField'\n\nexport const ArrayField = <D extends JSXComponent, C extends JSXComponent>(\n  props: IFieldProps<D, C, ArrayFieldType>\n) => {\n  const form = useForm()\n  const parent = useField()\n  const field = useAttach(\n    form.createArrayField({\n      basePath: parent?.address,\n      ...props,\n    })\n  )\n  return (\n    <FieldContext.Provider value={field}>\n      <ReactiveField field={field}>{props.children}</ReactiveField>\n    </FieldContext.Provider>\n  )\n}\n\nArrayField.displayName = 'ArrayField'\n","import React from 'react'\nimport { ObjectField as ObjectFieldType } from '@formily/core'\nimport { useForm, useField } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { ReactiveField } from './ReactiveField'\nimport { FieldContext } from '../shared'\nimport { JSXComponent, IFieldProps } from '../types'\n\nexport const ObjectField = <D extends JSXComponent, C extends JSXComponent>(\n  props: IFieldProps<D, C, ObjectFieldType>\n) => {\n  const form = useForm()\n  const parent = useField()\n  const field = useAttach(\n    form.createObjectField({ basePath: parent?.address, ...props })\n  )\n  return (\n    <FieldContext.Provider value={field}>\n      <ReactiveField field={field}>{props.children}</ReactiveField>\n    </FieldContext.Provider>\n  )\n}\n\nObjectField.displayName = 'ObjectField'\n","import React from 'react'\nimport { useForm, useField } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { ReactiveField } from './ReactiveField'\nimport { FieldContext } from '../shared'\nimport { JSXComponent, IVoidFieldProps } from '../types'\n\nexport const VoidField = <D extends JSXComponent, C extends JSXComponent>(\n  props: IVoidFieldProps<D, C>\n) => {\n  const form = useForm()\n  const parent = useField()\n  const field = useAttach(\n    form.createVoidField({ basePath: parent?.address, ...props })\n  )\n  return (\n    <FieldContext.Provider value={field}>\n      <ReactiveField field={field}>{props.children}</ReactiveField>\n    </FieldContext.Provider>\n  )\n}\n\nVoidField.displayName = 'VoidField'\n","import React from 'react'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { ReactiveField } from './ReactiveField'\nimport { FieldContext } from '../shared'\nimport { JSXComponent, IFieldProps } from '../types'\n\nexport const Field = <D extends JSXComponent, C extends JSXComponent>(\n  props: IFieldProps<D, C>\n) => {\n  const form = useForm()\n  const parent = useField()\n  const field = useAttach(\n    form.createField({ basePath: parent?.address, ...props })\n  )\n  return (\n    <FieldContext.Provider value={field}>\n      <ReactiveField field={field}>{props.children}</ReactiveField>\n    </FieldContext.Provider>\n  )\n}\n\nField.displayName = 'Field'\n","import React, { Fragment, useMemo } from 'react'\nimport { isFn, isValid } from '@formily/shared'\nimport { GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport { SchemaContext } from '../shared'\nimport { IRecursionFieldProps, ReactFC } from '../types'\nimport { useField, useExpressionScope } from '../hooks'\nimport { ObjectField } from './ObjectField'\nimport { ArrayField } from './ArrayField'\nimport { Field } from './Field'\nimport { VoidField } from './VoidField'\n\nconst useFieldProps = (schema: Schema) => {\n  const scope = useExpressionScope()\n  return schema.toFieldProps({\n    scope,\n  }) as any\n}\n\nconst useBasePath = (props: IRecursionFieldProps) => {\n  const parent = useField()\n  if (props.onlyRenderProperties) {\n    return props.basePath || parent?.address.concat(props.name)\n  }\n  return props.basePath || parent?.address\n}\n\nexport const RecursionField: ReactFC<IRecursionFieldProps> = (props) => {\n  const basePath = useBasePath(props)\n  const fieldSchema = useMemo(() => new Schema(props.schema), [props.schema])\n  const fieldProps = useFieldProps(fieldSchema)\n  const renderProperties = (field?: GeneralField) => {\n    if (props.onlyRenderSelf) return\n    const properties = Schema.getOrderProperties(fieldSchema)\n    if (!properties.length) return\n    return (\n      <Fragment>\n        {properties.map(({ schema: item, key: name }, index) => {\n          const base = field?.address || basePath\n          let schema: Schema = item\n          if (isFn(props.mapProperties)) {\n            const mapped = props.mapProperties(item, name)\n            if (mapped) {\n              schema = mapped\n            }\n          }\n          if (isFn(props.filterProperties)) {\n            if (props.filterProperties(schema, name) === false) {\n              return null\n            }\n          }\n          return (\n            <RecursionField\n              schema={schema}\n              key={`${index}-${name}`}\n              name={name}\n              basePath={base}\n            />\n          )\n        })}\n      </Fragment>\n    )\n  }\n\n  const render = () => {\n    if (!isValid(props.name)) return renderProperties()\n    if (fieldSchema.type === 'object') {\n      if (props.onlyRenderProperties) return renderProperties()\n      return (\n        <ObjectField {...fieldProps} name={props.name} basePath={basePath}>\n          {renderProperties}\n        </ObjectField>\n      )\n    } else if (fieldSchema.type === 'array') {\n      return (\n        <ArrayField {...fieldProps} name={props.name} basePath={basePath} />\n      )\n    } else if (fieldSchema.type === 'void') {\n      if (props.onlyRenderProperties) return renderProperties()\n      return (\n        <VoidField {...fieldProps} name={props.name} basePath={basePath}>\n          {renderProperties}\n        </VoidField>\n      )\n    }\n    return <Field {...fieldProps} name={props.name} basePath={basePath} />\n  }\n\n  if (!fieldSchema) return <Fragment />\n\n  return (\n    <SchemaContext.Provider value={fieldSchema}>\n      {render()}\n    </SchemaContext.Provider>\n  )\n}\n","import React, { useContext } from 'react'\nimport { lazyMerge } from '@formily/shared'\nimport { SchemaExpressionScopeContext } from '../shared'\nimport { IExpressionScopeProps, ReactFC } from '../types'\n\nexport const ExpressionScope: ReactFC<IExpressionScopeProps> = (props) => {\n  const scope = useContext(SchemaExpressionScopeContext)\n  return (\n    <SchemaExpressionScopeContext.Provider\n      value={lazyMerge(scope, props.value)}\n    >\n      {props.children}\n    </SchemaExpressionScopeContext.Provider>\n  )\n}\n","import React from 'react'\nimport { createPortal } from 'react-dom'\nimport { globalThisPolyfill } from '@formily/shared'\n\nconst env = {\n  portalDOM: null,\n}\n\nexport const render = (element: React.ReactElement) => {\n  if (globalThisPolyfill['document']) {\n    env.portalDOM =\n      env.portalDOM || globalThisPolyfill['document'].createElement('div')\n    return createPortal(element, env.portalDOM)\n  } else {\n    return React.createElement('template', {}, element)\n  }\n}\n","import React, { useContext, Fragment } from 'react'\nimport { ISchema, Schema } from '@formily/json-schema'\nimport { RecursionField } from './RecursionField'\nimport { render } from '../shared/render'\nimport {\n  SchemaMarkupContext,\n  SchemaOptionsContext,\n  SchemaComponentsContext,\n} from '../shared'\nimport {\n  ReactComponentPath,\n  JSXComponent,\n  ISchemaFieldReactFactoryOptions,\n  SchemaReactComponents,\n  ISchemaFieldProps,\n  ISchemaMarkupFieldProps,\n  ISchemaTypeFieldProps,\n} from '../types'\nimport { lazyMerge } from '@formily/shared'\nimport { ExpressionScope } from './ExpressionScope'\nconst env = {\n  nonameId: 0,\n}\n\nconst getRandomName = () => {\n  return `NO_NAME_FIELD_$${env.nonameId++}`\n}\n\nexport function createSchemaField<Components extends SchemaReactComponents>(\n  options: ISchemaFieldReactFactoryOptions<Components> = {}\n) {\n  function SchemaField<\n    Decorator extends JSXComponent,\n    Component extends JSXComponent\n  >(props: ISchemaFieldProps<Decorator, Component>) {\n    const schema = Schema.isSchemaInstance(props.schema)\n      ? props.schema\n      : new Schema({\n          type: 'object',\n          ...props.schema,\n        })\n    const renderMarkup = () => {\n      env.nonameId = 0\n      if (props.schema) return null\n      return render(\n        <SchemaMarkupContext.Provider value={schema}>\n          {props.children}\n        </SchemaMarkupContext.Provider>\n      )\n    }\n\n    const renderChildren = () => {\n      return <RecursionField {...props} schema={schema} />\n    }\n\n    return (\n      <SchemaOptionsContext.Provider value={options}>\n        <SchemaComponentsContext.Provider\n          value={lazyMerge(options.components, props.components)}\n        >\n          <ExpressionScope value={lazyMerge(options.scope, props.scope)}>\n            {renderMarkup()}\n            {renderChildren()}\n          </ExpressionScope>\n        </SchemaComponentsContext.Provider>\n      </SchemaOptionsContext.Provider>\n    )\n  }\n\n  SchemaField.displayName = 'SchemaField'\n\n  function MarkupRender(props: any) {\n    const parent = useContext(SchemaMarkupContext)\n    if (!parent) return <Fragment />\n    const renderChildren = () => {\n      return <React.Fragment>{props.children}</React.Fragment>\n    }\n    const appendArraySchema = (schema: ISchema) => {\n      const items = parent.items as Schema\n      if (items && items.name !== props.name) {\n        return parent.addProperty(props.name, schema)\n      } else {\n        return parent.setItems(schema)\n      }\n    }\n    if (parent.type === 'object' || parent.type === 'void') {\n      const schema = parent.addProperty(props.name, props)\n      return (\n        <SchemaMarkupContext.Provider value={schema}>\n          {renderChildren()}\n        </SchemaMarkupContext.Provider>\n      )\n    } else if (parent.type === 'array') {\n      const schema = appendArraySchema(props)\n      return (\n        <SchemaMarkupContext.Provider\n          value={Array.isArray(schema) ? schema[0] : schema}\n        >\n          {props.children}\n        </SchemaMarkupContext.Provider>\n      )\n    } else {\n      return renderChildren()\n    }\n  }\n\n  function MarkupField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaMarkupFieldProps<Components, Component, Decorator>) {\n    return <MarkupRender {...props} name={props.name || getRandomName()} />\n  }\n\n  MarkupField.displayName = 'MarkupField'\n\n  function StringField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"string\" />\n  }\n\n  StringField.displayName = 'StringField'\n\n  function ObjectField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"object\" />\n  }\n\n  ObjectField.displayName = 'ObjectField'\n\n  function ArrayField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"array\" />\n  }\n\n  ArrayField.displayName = 'ArrayField'\n  function BooleanField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"boolean\" />\n  }\n\n  BooleanField.displayName = 'BooleanField'\n\n  function NumberField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"number\" />\n  }\n\n  NumberField.displayName = 'NumberField'\n\n  function DateField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"date\" />\n  }\n\n  DateField.displayName = 'DateField'\n\n  function DateTimeField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"datetime\" />\n  }\n\n  DateTimeField.displayName = 'DateTimeField'\n\n  function VoidField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"void\" />\n  }\n\n  VoidField.displayName = 'VoidField'\n\n  SchemaField.Markup = MarkupField\n  SchemaField.String = StringField\n  SchemaField.Object = ObjectField\n  SchemaField.Array = ArrayField\n  SchemaField.Boolean = BooleanField\n  SchemaField.Date = DateField\n  SchemaField.DateTime = DateTimeField\n  SchemaField.Void = VoidField\n  SchemaField.Number = NumberField\n\n  return SchemaField\n}\n","import React from 'react'\nimport { lazyMerge } from '@formily/shared'\nimport { ExpressionScope } from './ExpressionScope'\nimport { ReactFC, IRecordScopeProps } from '../types'\nimport { useExpressionScope } from '../hooks'\n\nexport const RecordScope: ReactFC<IRecordScopeProps> = (props) => {\n  const scope = useExpressionScope()\n  return (\n    <ExpressionScope\n      value={{\n        get $lookup() {\n          return scope?.$record\n        },\n        get $record() {\n          const record = props.getRecord?.()\n          if (typeof record === 'object') {\n            return lazyMerge(record, {\n              get $lookup() {\n                return scope?.$record\n              },\n              get $index() {\n                return props.getIndex?.()\n              },\n            })\n          }\n          return record\n        },\n        get $index() {\n          return props.getIndex?.()\n        },\n      }}\n    >\n      {props.children}\n    </ExpressionScope>\n  )\n}\n","import React from 'react'\nimport { ExpressionScope } from './ExpressionScope'\nimport { ReactFC, IRecordsScopeProps } from '../types'\n\nexport const RecordsScope: ReactFC<IRecordsScopeProps> = (props) => {\n  return (\n    <ExpressionScope\n      value={{\n        get $records() {\n          return props.getRecords?.() ?? []\n        },\n      }}\n    >\n      {props.children}\n    </ExpressionScope>\n  )\n}\n","import React from 'react'\nimport { isFn, isStr, FormPath, each, isValid } from '@formily/shared'\nimport { isVoidField } from '@formily/core'\nimport { observer, Observer } from '@formily/reactive-react'\nimport { JSXComponent, IComponentMapper, IStateMapper } from '../types'\nimport { useField } from '../hooks'\nimport hoistNonReactStatics from 'hoist-non-react-statics'\n\nexport function mapProps<T extends JSXComponent>(\n  ...args: IStateMapper<React.ComponentProps<T>>[]\n) {\n  return (target: T) => {\n    return observer(\n      (props: any) => {\n        const field = useField()\n        const results = args.reduce(\n          (props, mapper) => {\n            if (isFn(mapper)) {\n              props = Object.assign(props, mapper(props, field))\n            } else {\n              each(mapper, (to, extract) => {\n                const extractValue = FormPath.getIn(field, extract)\n                const targetValue = isStr(to) ? to : (extract as any)\n                const originalValue = FormPath.getIn(props, targetValue)\n                if (extract === 'value') {\n                  if (to !== extract) {\n                    delete props.value\n                  }\n                }\n                if (isValid(originalValue) && !isValid(extractValue)) return\n                FormPath.setIn(props, targetValue, extractValue)\n              })\n            }\n            return props\n          },\n          { ...props }\n        )\n        return React.createElement(target, results)\n      },\n      {\n        forwardRef: true,\n      }\n    )\n  }\n}\n\nexport function mapReadPretty<T extends JSXComponent, C extends JSXComponent>(\n  component: C,\n  readPrettyProps?: React.ComponentProps<C>\n) {\n  return (target: T) => {\n    return observer(\n      (props) => {\n        const field = useField()\n        if (!isVoidField(field) && field?.pattern === 'readPretty') {\n          return React.createElement(component, {\n            ...readPrettyProps,\n            ...props,\n          })\n        }\n        return React.createElement(target, props)\n      },\n      {\n        forwardRef: true,\n      }\n    )\n  }\n}\n\nexport function connect<T extends JSXComponent>(\n  target: T,\n  ...args: IComponentMapper<T>[]\n) {\n  const Target = args.reduce((target, mapper) => {\n    return mapper(target)\n  }, target)\n\n  const Destination = React.forwardRef(\n    (props: Partial<React.ComponentProps<T>>, ref) => {\n      return React.createElement(Target, { ...props, ref })\n    }\n  )\n\n  if (target) hoistNonReactStatics(Destination, target as any)\n\n  return Destination\n}\n\nexport { observer, Observer }\n","import { useContext } from 'react'\nimport { SchemaContext } from '../shared'\nimport { Schema } from '@formily/json-schema'\n\nexport const useFieldSchema = (): Schema => {\n  return useContext(SchemaContext)\n}\n","import { unstable_useCompatFactory } from '@formily/reactive-react'\nimport { Form } from '@formily/core'\nimport { uid } from '@formily/shared'\nimport { useForm } from './useForm'\n\nexport const useFormEffects = (effects?: (form: Form) => void) => {\n  const form = useForm()\n  unstable_useCompatFactory(() => {\n    const id = uid()\n    form.addEffects(id, effects)\n    return {\n      dispose() {\n        form.removeEffects(id)\n      },\n    }\n  })\n}\n","import { isObjectField, GeneralField, Form, ObjectField } from '@formily/core'\nimport { useField } from './useField'\nimport { useForm } from './useForm'\n\nexport const useParentForm = (): Form | ObjectField => {\n  const field = useField()\n  const form = useForm()\n  const findObjectParent = (field: GeneralField) => {\n    if (!field) return form\n    if (isObjectField(field)) return field\n    return findObjectParent(field?.parent)\n  }\n  return findObjectParent(field)\n}\n"],"names":["REVA_ACTIONS_KEY","Symbol","for","SchemaNestedMap","parent","root","properties","patternProperties","additionalProperties","items","additionalItems","SchemaStateMap","title","description","default","enum","readOnly","writeOnly","SchemaValidatorMap","required","format","maxItems","minItems","maxLength","minLength","maximum","minimum","exclusiveMaximum","exclusiveMinimum","pattern","const","multipleOf","maxProperties","minProperties","uniqueItems","hasOwnProperty","Object","prototype","isNoNeedCompileObject","source","Schema","isSchemaInstance","Formily","Shared","isFn","Reactive","isObservable","patchStateFormSchema","targetState","compiled","untracked","_a","segments","FormPath","parse","key","isEnum","isArr","schemaMapKey","setIn","concat","slice","toArr","map","item","label","value","call","ExpRE","Registry","silent","compile","expression","scope","Function","registerCompiler","compiler","shallowCompile","isStr","matched","match","seenObjects","isPlainObj","indexOf","addIndex","length","push","results","reduce","buf","splice","patchCompile","sourceState","target","visitor","traverse","path","each","undefined","patchSchemaCompile","sourceSchema","demand","schema","String","traverseSchema","omitCompile","collected","hasCollected","initialized","__read","o","n","m","iterator","r","e","i","ar","next","done","error","FieldEffects","onFieldInit","Core","onFieldMount","onFieldUnmount","onFieldValueChange","onFieldInputValueChange","onFieldInitialValueChange","onFieldValidateStart","onFieldValidateEnd","onFieldValidateFailed","onFieldValidateSuccess","DefaultFieldEffects","getDependencyValue","field","property","split","query","getIn","setSchemaFieldState","options","request","runner","state","form","setFieldState","lazyMerge","$target","setState","getBaseScope","$effect","autorun","effect","$memo","memo","$self","$form","$values","values","$observable","deps","observable","$props","props","setComponentProps","getBaseReactions","getUserReactions","unCompiled","baseScope","reaction","when","fulfill","otherwise","effects","run","$deps","dependencies","results_1","forEach","name","getDependencies","$dependencies","compiledWhen","condition","type","address","__assign","assign","t","s","arguments","p","apply","this","patches","polyfills","registerPatches","args","_i","patch","registerPolyfills","version","enablePolyfills","versions","__spreadArray","to","from","pack","l","Array","VOID_COMPONENTS","TYPE_DEFAULT_COMPONENTS","transformCondition","replace","SpecificationV1Polyfill","linkages","isValid","visible","some","component","lowerCase","registerVoidComponents","components","registerTypeDefaultComponents","maps","json","_this","_isJSONSchemaObject","addProperty","removeProperty","setProperties","addPatternProperty","removePatternProperty","setPatternProperties","setAdditionalProperties","setItems","isArray","setAdditionalItems","findDefinitions","ref","substring","mapProperties","callback","getOrderProperties","index","mapPatternProperties","reduceProperties","predicate","reducePatternProperties","includes","fromJSON","toJSON","recursion","_b","toFieldProps","reactions","transformFieldProps","propertiesName","orderProperties","unorderProperties","isNaN","filter","instOf","useAttach","ReactiveReact","unstable_useCompatEffect","FormContext","React","createContext","FieldContext","SchemaMarkupContext","SchemaContext","SchemaExpressionScopeContext","SchemaComponentsContext","SchemaOptionsContext","ContextCleaner","children","contexts","ctx","createElement","Provider","createContextCleaner","useForm","useContext","useField","useExpressionScope","REACT_STATICS","childContextTypes","contextType","contextTypes","defaultProps","displayName","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","KNOWN_STATICS","caller","callee","arity","MEMO_STATICS","$$typeof","compare","TYPE_STATICS","getStatics","reactIs","isMemo","ForwardRef","render","Memo","defineProperty","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","getPrototypeOf","objectPrototype","hoistNonReactStatics_cjs","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","inheritedComponent","keys","targetStatics","sourceStatics","descriptor","FormProvider","FormConsumer","observer","Fragment","renderChildren","ReactiveInternal","content","mergeChildren","componentProps","display","isVoidField","onChange","onInput","onFocus","onBlur","_c","disabled","getComponent","componentType","toJS","renderComponent","decoratorType","decoratorProps","ReactiveField","forwardRef","ArrayField","ObjectField","VoidField","Field","RecursionField","basePath","useBasePath","fieldSchema","useMemo","JSONSchema","fieldProps","base","mapped","filterProperties","renderProperties","ExpressionScope","env","portalDOM","nonameId","$lookup","$record","record","getRecord","$index","getIndex","$records","mapper","Destination","element","globalThisPolyfill","ReactDOM","createPortal","appendArraySchema","MarkupRender","SchemaField","MarkupField","StringField","BooleanField","NumberField","DateField","DateTimeField","Markup","Boolean","Date","DateTime","Void","Number","extract","targetValue","extractValue","readPrettyProps","unstable_useCompatFactory","id","uid","addEffects","removeEffects","isObjectField","findObjectParent"],"mappings":"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"}