{"version":3,"file":"formily.reactive.umd.production.js","sources":["../src/checkers.ts","../src/array.ts","../src/environment.ts","../src/reaction.ts","../src/tree.ts","../src/externals.ts","../src/handlers.ts","../src/internals.ts","../src/batch.ts","../src/action.ts","../src/untracked.ts","../src/annotations/observable.ts","../src/annotations/box.ts","../src/annotations/ref.ts","../src/annotations/shallow.ts","../src/annotations/computed.ts","../src/observable.ts","../src/model.ts","../src/autorun.ts","../src/tracker.ts","../src/observe.ts"],"sourcesContent":["const toString = Object.prototype.toString\nexport const isMap = (val: any): val is Map<any, any> =>\n  val && val instanceof Map\nexport const isSet = (val: any): val is Set<any> => val && val instanceof Set\nexport const isWeakMap = (val: any): val is WeakMap<any, any> =>\n  val && val instanceof WeakMap\nexport const isWeakSet = (val: any): val is WeakSet<any> =>\n  val && val instanceof WeakSet\nexport const isFn = (val: any): val is Function => typeof val === 'function'\nexport const isArr = Array.isArray\nexport const isPlainObj = (val: any): val is object =>\n  toString.call(val) === '[object Object]'\nexport const isValid = (val: any) => val !== null && val !== undefined\nexport const isCollectionType = (target: any) => {\n  return (\n    isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target)\n  )\n}\nexport const isNormalType = (target: any) => {\n  return isPlainObj(target) || isArr(target)\n}\n","export const toArray = (value: any) => {\n  return Array.isArray(value)\n    ? value\n    : value !== undefined && value !== null\n    ? [value]\n    : []\n}\n\nexport class ArraySet<T> {\n  value: T[]\n  forEachIndex = 0\n  constructor(value: T[] = []) {\n    this.value = value\n  }\n\n  add(item: T) {\n    if (!this.has(item)) {\n      this.value.push(item)\n    }\n  }\n\n  has(item: T) {\n    return this.value.indexOf(item) > -1\n  }\n\n  delete(item: T) {\n    const findIndex = this.value.indexOf(item)\n    if (findIndex > -1) {\n      this.value.splice(findIndex, 1)\n      if (findIndex <= this.forEachIndex) {\n        this.forEachIndex -= 1\n      }\n    }\n  }\n\n  forEach(callback: (value: T) => void) {\n    if (this.value.length === 0) return\n    this.forEachIndex = 0\n    for (; this.forEachIndex < this.value.length; this.forEachIndex++) {\n      callback(this.value[this.forEachIndex])\n    }\n  }\n\n  batchDelete(callback: (value: T) => void) {\n    if (this.value.length === 0) return\n    this.forEachIndex = 0\n    for (; this.forEachIndex < this.value.length; this.forEachIndex++) {\n      const value = this.value[this.forEachIndex]\n      this.value.splice(this.forEachIndex, 1)\n      this.forEachIndex--\n      callback(value)\n    }\n  }\n\n  clear() {\n    this.value.length = 0\n  }\n}\n","import { ObservableListener, Reaction, ReactionsMap } from './types'\nimport { ArraySet } from './array'\nimport { DataNode } from './tree'\n\nexport const ProxyRaw = new WeakMap()\nexport const RawProxy = new WeakMap()\nexport const RawShallowProxy = new WeakMap()\nexport const RawNode = new WeakMap<object, DataNode>()\nexport const RawReactionsMap = new WeakMap<object, ReactionsMap>()\n\nexport const ReactionStack: Reaction[] = []\nexport const BatchCount = { value: 0 }\nexport const UntrackCount = { value: 0 }\nexport const BatchScope = { value: false }\nexport const DependencyCollected = { value: false }\nexport const PendingReactions = new ArraySet<Reaction>()\nexport const PendingScopeReactions = new ArraySet<Reaction>()\nexport const BatchEndpoints = new ArraySet<() => void>()\nexport const MakeObservableSymbol = Symbol('MakeObservableSymbol')\nexport const ObserverListeners = new ArraySet<ObservableListener>()\n","import { isFn } from './checkers'\nimport { ArraySet } from './array'\nimport { IOperation, ReactionsMap, Reaction, PropertyKey } from './types'\nimport {\n  ReactionStack,\n  PendingScopeReactions,\n  BatchEndpoints,\n  DependencyCollected,\n  RawReactionsMap,\n  PendingReactions,\n  BatchCount,\n  UntrackCount,\n  BatchScope,\n  ObserverListeners,\n} from './environment'\n\nconst ITERATION_KEY = Symbol('iteration key')\n\nconst addRawReactionsMap = (\n  target: any,\n  key: PropertyKey,\n  reaction: Reaction\n) => {\n  const reactionsMap = RawReactionsMap.get(target)\n  if (reactionsMap) {\n    const reactions = reactionsMap.get(key)\n    if (reactions) {\n      reactions.add(reaction)\n    } else {\n      reactionsMap.set(key, new ArraySet([reaction]))\n    }\n    return reactionsMap\n  } else {\n    const reactionsMap: ReactionsMap = new Map([\n      [key, new ArraySet([reaction])],\n    ])\n    RawReactionsMap.set(target, reactionsMap)\n    return reactionsMap\n  }\n}\n\nconst addReactionsMapToReaction = (\n  reaction: Reaction,\n  reactionsMap: ReactionsMap\n) => {\n  const bindSet = reaction._reactionsSet\n  if (bindSet) {\n    bindSet.add(reactionsMap)\n  } else {\n    reaction._reactionsSet = new ArraySet([reactionsMap])\n  }\n  return bindSet\n}\n\nconst getReactionsFromTargetKey = (target: any, key: PropertyKey) => {\n  const reactionsMap = RawReactionsMap.get(target)\n  const reactions = []\n  if (reactionsMap) {\n    const map = reactionsMap.get(key)\n    if (map) {\n      map.forEach((reaction) => {\n        if (reactions.indexOf(reaction) === -1) {\n          reactions.push(reaction)\n        }\n      })\n    }\n  }\n  return reactions\n}\n\nconst runReactions = (target: any, key: PropertyKey) => {\n  const reactions = getReactionsFromTargetKey(target, key)\n  const prevUntrackCount = UntrackCount.value\n  UntrackCount.value = 0\n  for (let i = 0, len = reactions.length; i < len; i++) {\n    const reaction = reactions[i]\n    if (reaction._isComputed) {\n      reaction._scheduler(reaction)\n    } else if (isScopeBatching()) {\n      PendingScopeReactions.add(reaction)\n    } else if (isBatching()) {\n      PendingReactions.add(reaction)\n    } else {\n      if (isFn(reaction._scheduler)) {\n        reaction._scheduler(reaction)\n      } else {\n        reaction()\n      }\n    }\n  }\n  UntrackCount.value = prevUntrackCount\n}\n\nconst notifyObservers = (operation: IOperation) => {\n  ObserverListeners.forEach((fn) => fn(operation))\n}\n\nexport const bindTargetKeyWithCurrentReaction = (operation: IOperation) => {\n  let { key, type, target } = operation\n  if (type === 'iterate') {\n    key = ITERATION_KEY\n  }\n\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (isUntracking()) return\n  if (current) {\n    DependencyCollected.value = true\n    addReactionsMapToReaction(current, addRawReactionsMap(target, key, current))\n  }\n}\n\nexport const bindComputedReactions = (reaction: Reaction) => {\n  if (isFn(reaction)) {\n    const current = ReactionStack[ReactionStack.length - 1]\n    if (current) {\n      const computes = current._computesSet\n      if (computes) {\n        computes.add(reaction)\n      } else {\n        current._computesSet = new ArraySet([reaction])\n      }\n    }\n  }\n}\n\nexport const runReactionsFromTargetKey = (operation: IOperation) => {\n  let { key, type, target, oldTarget } = operation\n  batchStart()\n  notifyObservers(operation)\n  if (type === 'clear') {\n    oldTarget.forEach((_: any, key: PropertyKey) => {\n      runReactions(target, key)\n    })\n  } else {\n    runReactions(target, key)\n  }\n  if (type === 'add' || type === 'delete' || type === 'clear') {\n    const newKey = Array.isArray(target) ? 'length' : ITERATION_KEY\n    runReactions(target, newKey)\n  }\n  batchEnd()\n}\n\nexport const hasRunningReaction = () => {\n  return ReactionStack.length > 0\n}\n\nexport const releaseBindingReactions = (reaction: Reaction) => {\n  reaction._reactionsSet?.forEach((reactionsMap) => {\n    reactionsMap.forEach((reactions) => {\n      reactions.delete(reaction)\n    })\n  })\n  PendingReactions.delete(reaction)\n  PendingScopeReactions.delete(reaction)\n  delete reaction._reactionsSet\n}\n\nexport const suspendComputedReactions = (current: Reaction) => {\n  current._computesSet?.forEach((reaction) => {\n    const reactions = getReactionsFromTargetKey(\n      reaction._context,\n      reaction._property\n    )\n    if (reactions.length === 0) {\n      disposeBindingReactions(reaction)\n      reaction._dirty = true\n    }\n  })\n}\n\nexport const disposeBindingReactions = (reaction: Reaction) => {\n  reaction._disposed = true\n  releaseBindingReactions(reaction)\n  suspendComputedReactions(reaction)\n}\n\nexport const batchStart = () => {\n  BatchCount.value++\n}\n\nexport const batchEnd = () => {\n  BatchCount.value--\n  if (BatchCount.value === 0) {\n    const prevUntrackCount = UntrackCount.value\n    UntrackCount.value = 0\n    executePendingReactions()\n    executeBatchEndpoints()\n    UntrackCount.value = prevUntrackCount\n  }\n}\n\nexport const batchScopeStart = () => {\n  BatchScope.value = true\n}\n\nexport const batchScopeEnd = () => {\n  const prevUntrackCount = UntrackCount.value\n  BatchScope.value = false\n  UntrackCount.value = 0\n  PendingScopeReactions.batchDelete((reaction) => {\n    if (isFn(reaction._scheduler)) {\n      reaction._scheduler(reaction)\n    } else {\n      reaction()\n    }\n  })\n  UntrackCount.value = prevUntrackCount\n}\n\nexport const untrackStart = () => {\n  UntrackCount.value++\n}\n\nexport const untrackEnd = () => {\n  UntrackCount.value--\n}\n\nexport const isBatching = () => BatchCount.value > 0\n\nexport const isScopeBatching = () => BatchScope.value\n\nexport const isUntracking = () => UntrackCount.value > 0\n\nexport const executePendingReactions = () => {\n  PendingReactions.batchDelete((reaction) => {\n    if (isFn(reaction._scheduler)) {\n      reaction._scheduler(reaction)\n    } else {\n      reaction()\n    }\n  })\n}\n\nexport const executeBatchEndpoints = () => {\n  BatchEndpoints.batchDelete((callback) => {\n    callback()\n  })\n}\n\nexport const hasDepsChange = (newDeps: any[], oldDeps: any[]) => {\n  if (newDeps === oldDeps) return false\n  if (newDeps.length !== oldDeps.length) return true\n  if (newDeps.some((value, index) => value !== oldDeps[index])) return true\n  return false\n}\n\nexport const disposeEffects = (reaction: Reaction) => {\n  if (reaction._effects) {\n    try {\n      batchStart()\n      reaction._effects.queue.forEach((item) => {\n        if (!item || !item.dispose) return\n        item.dispose()\n      })\n    } finally {\n      batchEnd()\n    }\n  }\n}\n","import { RawNode, ProxyRaw } from './environment'\nimport { PropertyKey, IOperation } from './types'\nexport class DataChange {\n  node: DataNode\n  key: PropertyKey\n  object: object\n  type: string\n  value: any\n  oldValue: any\n  constructor(operation: IOperation, node: DataNode) {\n    this.node = node\n    this.key = operation.key\n    this.type = operation.type\n    this.object = operation.target\n    this.value = operation.value\n    this.oldValue = operation.oldValue\n  }\n\n  get path() {\n    return this.node.path.concat(this.key)\n  }\n}\nexport class DataNode {\n  target: any\n\n  key: PropertyKey\n\n  value: any\n\n  constructor(target: any, key: PropertyKey, value: any) {\n    this.target = target\n    this.key = key\n    this.value = value\n  }\n\n  get path() {\n    if (!this.parent) return this.key ? [this.key] : []\n    return this.parent.path.concat(this.key)\n  }\n\n  get targetRaw() {\n    return ProxyRaw.get(this.target) || this.target\n  }\n\n  get parent() {\n    if (!this.target) return\n    return getDataNode(this.targetRaw)\n  }\n\n  isEqual(node: DataNode) {\n    if (this.key) {\n      return node.targetRaw === this.targetRaw && node.key === this.key\n    }\n    return node.value === this.value\n  }\n\n  contains(node: DataNode) {\n    if (node === this) return true\n    let parent = node.parent\n    while (!!parent) {\n      if (this.isEqual(parent)) return true\n      parent = parent.parent\n    }\n    return false\n  }\n}\n\nexport const getDataNode = (raw: any) => {\n  return RawNode.get(raw)\n}\n\nexport const setDataNode = (raw: any, node: DataNode) => {\n  RawNode.set(raw, node)\n}\n\nexport const buildDataTree = (target: any, key: PropertyKey, value: any) => {\n  const raw = ProxyRaw.get(value) || value\n  const currentNode = getDataNode(raw)\n  if (currentNode) return currentNode\n  setDataNode(raw, new DataNode(target, key, value))\n}\n","import {\n  isValid,\n  isFn,\n  isMap,\n  isWeakMap,\n  isSet,\n  isWeakSet,\n  isPlainObj,\n  isArr,\n} from './checkers'\nimport {\n  ProxyRaw,\n  MakeObservableSymbol,\n  DependencyCollected,\n} from './environment'\nimport { getDataNode } from './tree'\nimport { Annotation } from './types'\n\nconst RAW_TYPE = Symbol('RAW_TYPE')\nconst OBSERVABLE_TYPE = Symbol('OBSERVABLE_TYPE')\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nexport const isObservable = (target: any) => {\n  return ProxyRaw.has(target)\n}\n\nexport const isAnnotation = (target: any): target is Annotation => {\n  return target && !!target[MakeObservableSymbol]\n}\n\nexport const isSupportObservable = (target: any) => {\n  if (!isValid(target)) return false\n  if (isArr(target)) return true\n  if (isPlainObj(target)) {\n    if (target[RAW_TYPE]) {\n      return false\n    }\n    if (target[OBSERVABLE_TYPE]) {\n      return true\n    }\n    if ('$$typeof' in target && '_owner' in target) {\n      return false\n    }\n    if (target['_isAMomentObject']) {\n      return false\n    }\n    if (target['_isJSONSchemaObject']) {\n      return false\n    }\n    if (isFn(target['toJS'])) {\n      return false\n    }\n    if (isFn(target['toJSON'])) {\n      return false\n    }\n    return true\n  }\n  if (isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target))\n    return true\n  return false\n}\n\nexport const markRaw = <T>(target: T): T => {\n  if (!target) return\n  if (isFn(target)) {\n    target.prototype[RAW_TYPE] = true\n  } else {\n    target[RAW_TYPE] = true\n  }\n  return target\n}\n\nexport const markObservable = <T>(target: T): T => {\n  if (!target) return\n  if (isFn(target)) {\n    target.prototype[OBSERVABLE_TYPE] = true\n  } else {\n    target[OBSERVABLE_TYPE] = true\n  }\n  return target\n}\n\nexport const raw = <T>(target: T): T => ProxyRaw.get(target as any)\n\nexport const toJS = <T>(values: T): T => {\n  const visited = new WeakSet<any>()\n  const _toJS: typeof toJS = (values: any) => {\n    if (visited.has(values)) {\n      return values\n    }\n    if (values && values[RAW_TYPE]) return values\n    if (isArr(values)) {\n      if (isObservable(values)) {\n        visited.add(values)\n        const res: any = []\n        values.forEach((item: any) => {\n          res.push(_toJS(item))\n        })\n        visited.delete(values)\n        return res\n      }\n    } else if (isPlainObj(values)) {\n      if (isObservable(values)) {\n        visited.add(values)\n        const res: any = {}\n        for (const key in values) {\n          if (hasOwnProperty.call(values, key)) {\n            res[key] = _toJS(values[key])\n          }\n        }\n        visited.delete(values)\n        return res\n      }\n    }\n    return values\n  }\n\n  return _toJS(values)\n}\n\nexport const contains = (target: any, property: any) => {\n  const targetRaw = ProxyRaw.get(target) || target\n  const propertyRaw = ProxyRaw.get(property) || property\n  if (targetRaw === propertyRaw) return true\n  const targetNode = getDataNode(targetRaw)\n  const propertyNode = getDataNode(propertyRaw)\n  if (!targetNode) return false\n  if (!propertyNode) return false\n  return targetNode.contains(propertyNode)\n}\n\nexport const hasCollected = (callback?: () => void) => {\n  DependencyCollected.value = false\n  callback?.()\n  return DependencyCollected.value\n}\n","import {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from './reaction'\nimport { ProxyRaw, RawProxy } from './environment'\nimport { isObservable, isSupportObservable } from './externals'\nimport { createObservable } from './internals'\n\nconst wellKnownSymbols = new Set(\n  Object.getOwnPropertyNames(Symbol)\n    .map((key) => Symbol[key])\n    .filter((value) => typeof value === 'symbol')\n)\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction findObservable(target: any, key: PropertyKey, value: any) {\n  const observableObj = RawProxy.get(value)\n  if (observableObj) {\n    return observableObj\n  }\n  if (!isObservable(value) && isSupportObservable(value)) {\n    return createObservable(target, key, value)\n  }\n  return value\n}\n\nfunction patchIterator(\n  target: any,\n  key: PropertyKey,\n  iterator: IterableIterator<any>,\n  isEntries: boolean\n) {\n  const originalNext = iterator.next\n  iterator.next = () => {\n    let { done, value } = originalNext.call(iterator)\n    if (!done) {\n      if (isEntries) {\n        value[1] = findObservable(target, key, value[1])\n      } else {\n        value = findObservable(target, key, value)\n      }\n    }\n    return { done, value }\n  }\n  return iterator\n}\n\nconst instrumentations = {\n  has(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'has' })\n    return proto.has.apply(target, arguments)\n  },\n  get(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'get' })\n    return findObservable(target, key, proto.get.apply(target, arguments))\n  },\n  add(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    // forward the operation before queueing reactions\n    const result = proto.add.apply(target, arguments)\n    if (!hadKey) {\n      runReactionsFromTargetKey({ target, key, value: key, type: 'add' })\n    }\n    return result\n  },\n  set(key: PropertyKey, value: any) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    const oldValue = proto.get.call(target, key)\n    // forward the operation before queueing reactions\n    const result = proto.set.apply(target, arguments)\n    if (!hadKey) {\n      runReactionsFromTargetKey({ target, key, value, type: 'add' })\n    } else if (value !== oldValue) {\n      runReactionsFromTargetKey({ target, key, value, oldValue, type: 'set' })\n    }\n    return result\n  },\n  delete(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    const oldValue = proto.get ? proto.get.call(target, key) : undefined\n    // forward the operation before queueing reactions\n    const result = proto.delete.apply(target, arguments)\n    if (hadKey) {\n      runReactionsFromTargetKey({ target, key, oldValue, type: 'delete' })\n    }\n    return result\n  },\n  clear() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadItems = target.size !== 0\n    const oldTarget = target instanceof Map ? new Map(target) : new Set(target)\n    // forward the operation before queueing reactions\n    const result = proto.clear.apply(target, arguments)\n    if (hadItems) {\n      runReactionsFromTargetKey({ target, oldTarget, type: 'clear' })\n    }\n    return result\n  },\n  forEach(cb: any, ...args: any[]) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    // swap out the raw values with their observable pairs\n    // before passing them to the callback\n    const wrappedCb = (value: any, key: PropertyKey, ...args: any) =>\n      cb(findObservable(target, key, value), key, ...args)\n    return proto.forEach.call(target, wrappedCb, ...args)\n  },\n  keys() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return proto.keys.apply(target, arguments)\n  },\n  values() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto.values.apply(target, arguments)\n    return patchIterator(target, '', iterator, false)\n  },\n  entries() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto.entries.apply(target, arguments)\n    return patchIterator(target, '', iterator, true)\n  },\n  [Symbol.iterator]() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto[Symbol.iterator].apply(target, arguments)\n    return patchIterator(target, '', iterator, target instanceof Map)\n  },\n  get size() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return Reflect.get(proto, 'size', target)\n  },\n}\n\nexport const collectionHandlers = {\n  get(target: any, key: PropertyKey, receiver: any) {\n    // instrument methods and property accessors to be reactive\n    target = hasOwnProperty.call(instrumentations, key)\n      ? instrumentations\n      : target\n    return Reflect.get(target, key, receiver)\n  },\n}\n\nexport const baseHandlers: ProxyHandler<any> = {\n  get(target, key, receiver) {\n    if (!key) return\n    const result = target[key] // use Reflect.get is too slow\n    if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {\n      return result\n    }\n    bindTargetKeyWithCurrentReaction({ target, key, receiver, type: 'get' })\n    const observableResult = RawProxy.get(result)\n    if (observableResult) {\n      return observableResult\n    }\n    if (!isObservable(result) && isSupportObservable(result)) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key)\n      if (\n        !descriptor ||\n        !(descriptor.writable === false && descriptor.configurable === false)\n      ) {\n        return createObservable(target, key, result)\n      }\n    }\n    return result\n  },\n  has(target, key) {\n    const result = Reflect.has(target, key)\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'has' })\n    return result\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return keys\n  },\n  set(target, key, value, receiver) {\n    const hadKey = hasOwnProperty.call(target, key)\n    const newValue = createObservable(target, key, value)\n    const oldValue = target[key]\n    target[key] = newValue // use Reflect.set is too slow\n    if (!hadKey) {\n      runReactionsFromTargetKey({\n        target,\n        key,\n        value: newValue,\n        oldValue,\n        receiver,\n        type: 'add',\n      })\n    } else if (value !== oldValue) {\n      runReactionsFromTargetKey({\n        target,\n        key,\n        value: newValue,\n        oldValue,\n        receiver,\n        type: 'set',\n      })\n    }\n    return true\n  },\n  deleteProperty(target, key) {\n    const oldValue = target[key]\n    delete target[key]\n    runReactionsFromTargetKey({\n      target,\n      key,\n      oldValue,\n      type: 'delete',\n    })\n    return true\n  },\n}\n","import { isFn, isCollectionType, isNormalType } from './checkers'\nimport {\n  RawProxy,\n  ProxyRaw,\n  MakeObservableSymbol,\n  RawShallowProxy,\n} from './environment'\nimport { baseHandlers, collectionHandlers } from './handlers'\nimport { buildDataTree, getDataNode } from './tree'\nimport { isSupportObservable } from './externals'\nimport { PropertyKey, IVisitor, BoundaryFunction } from './types'\n\nconst createNormalProxy = (target: any, shallow?: boolean) => {\n  const proxy = new Proxy(target, baseHandlers)\n  ProxyRaw.set(proxy, target)\n  if (shallow) {\n    RawShallowProxy.set(target, proxy)\n  } else {\n    RawProxy.set(target, proxy)\n  }\n  return proxy\n}\n\nconst createCollectionProxy = (target: any, shallow?: boolean) => {\n  const proxy = new Proxy(target, collectionHandlers)\n  ProxyRaw.set(proxy, target)\n  if (shallow) {\n    RawShallowProxy.set(target, proxy)\n  } else {\n    RawProxy.set(target, proxy)\n  }\n  return proxy\n}\n\nconst createShallowProxy = (target: any) => {\n  if (isNormalType(target)) return createNormalProxy(target, true)\n  if (isCollectionType(target)) return createCollectionProxy(target, true)\n  return target\n}\n\nexport const createObservable = (\n  target: any,\n  key?: PropertyKey,\n  value?: any,\n  shallow?: boolean\n) => {\n  if (typeof value !== 'object') return value\n  const raw = ProxyRaw.get(value)\n  if (!!raw) {\n    const node = getDataNode(raw)\n    if (!node.target) node.target = target\n    node.key = key\n    return value\n  }\n\n  if (!isSupportObservable(value)) return value\n\n  if (target) {\n    const parentRaw = ProxyRaw.get(target) || target\n    const isShallowParent = RawShallowProxy.get(parentRaw)\n    if (isShallowParent) return value\n  }\n\n  buildDataTree(target, key, value)\n  if (shallow) return createShallowProxy(value)\n  if (isNormalType(value)) return createNormalProxy(value)\n  if (isCollectionType(value)) return createCollectionProxy(value)\n  return value\n}\n\nexport const createAnnotation = <T extends (visitor: IVisitor) => any>(\n  maker: T\n) => {\n  const annotation = (target: any): ReturnType<T> => {\n    return maker({ value: target })\n  }\n  if (isFn(maker)) {\n    annotation[MakeObservableSymbol] = maker\n  }\n  return annotation\n}\n\nexport const getObservableMaker = (target: any) => {\n  if (target[MakeObservableSymbol]) {\n    if (!target[MakeObservableSymbol][MakeObservableSymbol]) {\n      return target[MakeObservableSymbol]\n    }\n    return getObservableMaker(target[MakeObservableSymbol])\n  }\n}\n\nexport const createBoundaryFunction = (\n  start: (...args: any) => void,\n  end: (...args: any) => void\n) => {\n  function boundary<F extends (...args: any) => any>(fn?: F): ReturnType<F> {\n    let results: ReturnType<F>\n    try {\n      start()\n      if (isFn(fn)) {\n        results = fn()\n      }\n    } finally {\n      end()\n    }\n    return results\n  }\n\n  boundary.bound = createBindFunction(boundary)\n  return boundary\n}\n\nexport const createBindFunction = <Boundary extends BoundaryFunction>(\n  boundary: Boundary\n) => {\n  function bind<F extends (...args: any[]) => any>(\n    callback?: F,\n    context?: any\n  ): F {\n    return ((...args: any[]) =>\n      boundary(() => callback.apply(context, args))) as any\n  }\n  return bind\n}\n\nexport const createBoundaryAnnotation = (\n  start: (...args: any) => void,\n  end: (...args: any) => void\n) => {\n  const boundary = createBoundaryFunction(start, end)\n  const annotation = createAnnotation(({ target, key }) => {\n    target[key] = boundary.bound(target[key], target)\n    return target\n  })\n  boundary[MakeObservableSymbol] = annotation\n  boundary.bound[MakeObservableSymbol] = annotation\n  return boundary\n}\n","import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n} from './reaction'\nimport { BatchEndpoints, BatchCount } from './environment'\nimport { createBoundaryAnnotation } from './internals'\nimport { IBatch } from './types'\nimport { isFn } from './checkers'\n\nexport const batch: IBatch = createBoundaryAnnotation(batchStart, batchEnd)\nbatch.scope = createBoundaryAnnotation(batchScopeStart, batchScopeEnd)\nbatch.endpoint = (callback?: () => void) => {\n  if (!isFn(callback)) return\n  if (BatchCount.value === 0) {\n    callback()\n  } else {\n    BatchEndpoints.add(callback)\n  }\n}\n","import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n  untrackStart,\n  untrackEnd,\n} from './reaction'\nimport { createBoundaryAnnotation } from './internals'\nimport { IAction } from './types'\n\nexport const action: IAction = createBoundaryAnnotation(\n  () => {\n    batchStart()\n    untrackStart()\n  },\n  () => {\n    untrackEnd()\n    batchEnd()\n  }\n)\n\naction.scope = createBoundaryAnnotation(\n  () => {\n    batchScopeStart()\n    untrackStart()\n  },\n  () => {\n    untrackEnd()\n    batchScopeEnd()\n  }\n)\n","import { createBoundaryFunction } from './internals'\nimport { untrackStart, untrackEnd } from './reaction'\n\nexport const untracked = createBoundaryFunction(untrackStart, untrackEnd)\n","import { createAnnotation, createObservable } from '../internals'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IObservable {\n  <T>(target: T): T\n}\n\nexport const observable: IObservable = createAnnotation(\n  ({ target, key, value }) => {\n    const store = {\n      value: createObservable(target, key, target ? target[key] : value),\n    }\n\n    function get() {\n      bindTargetKeyWithCurrentReaction({\n        target: target,\n        key: key,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      const oldValue = store.value\n      value = createObservable(target, key, value)\n      store.value = value\n      if (oldValue === value) return\n      runReactionsFromTargetKey({\n        target: target,\n        key: key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        set,\n        get,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    }\n    return store.value\n  }\n)\n","import { ProxyRaw, RawProxy } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IBox {\n  <T>(target: T): { get(): T; set(value: T): void }\n}\n\nexport const box: IBox = createAnnotation(({ target, key, value }) => {\n  const store = {\n    value: target ? target[key] : value,\n  }\n\n  const proxy = {\n    set,\n    get,\n  }\n\n  ProxyRaw.set(proxy, store)\n  RawProxy.set(store, proxy)\n\n  buildDataTree(target, key, store)\n\n  function get() {\n    bindTargetKeyWithCurrentReaction({\n      target: store,\n      key,\n      type: 'get',\n    })\n    return store.value\n  }\n\n  function set(value: any) {\n    const oldValue = store.value\n    store.value = value\n    if (oldValue !== value) {\n      runReactionsFromTargetKey({\n        target: store,\n        key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n  }\n\n  if (target) {\n    Object.defineProperty(target, key, {\n      value: proxy,\n      enumerable: true,\n      configurable: false,\n      writable: false,\n    })\n    return target\n  }\n  return proxy\n})\n","import { ProxyRaw, RawProxy } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IRef {\n  <T>(target: T): { value: T }\n}\n\nexport const ref: IRef = createAnnotation(({ target, key, value }) => {\n  const store = {\n    value: target ? target[key] : value,\n  }\n\n  const proxy = {}\n\n  const context = target ? target : store\n  const property = target ? key : 'value'\n\n  function get() {\n    bindTargetKeyWithCurrentReaction({\n      target: context,\n      key: property,\n      type: 'get',\n    })\n    return store.value\n  }\n\n  function set(value: any) {\n    const oldValue = store.value\n    store.value = value\n    if (oldValue !== value) {\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n  }\n  if (target) {\n    Object.defineProperty(target, key, {\n      get,\n      set,\n      enumerable: true,\n    })\n    return target\n  } else {\n    Object.defineProperty(proxy, 'value', {\n      set,\n      get,\n    })\n    buildDataTree(target, key, store)\n    ProxyRaw.set(proxy, store)\n    RawProxy.set(store, proxy)\n  }\n  return proxy\n})\n","import { createAnnotation, createObservable } from '../internals'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\nimport { IObservable } from './observable'\n\nexport const shallow: IObservable = createAnnotation(\n  ({ target, key, value }) => {\n    const store = {\n      value: createObservable(target, key, target ? target[key] : value, true),\n    }\n\n    function get() {\n      bindTargetKeyWithCurrentReaction({\n        target: target,\n        key: key,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      const oldValue = store.value\n      value = createObservable(target, key, value, true)\n      store.value = value\n      if (oldValue === value) return\n      runReactionsFromTargetKey({\n        target: target,\n        key: key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        set,\n        get,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    }\n    return store.value\n  }\n)\n","import { ProxyRaw, RawProxy, ReactionStack } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport { isFn } from '../checkers'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n  bindComputedReactions,\n  hasRunningReaction,\n  isUntracking,\n  batchStart,\n  batchEnd,\n  releaseBindingReactions,\n} from '../reaction'\n\ninterface IValue<T = any> {\n  value?: T\n}\nexport interface IComputed {\n  <T>(compute: () => T): IValue<T>\n  <T>(compute: { get?: () => T; set?: (value: T) => void }): IValue<T>\n}\n\nconst getDescriptor = Object.getOwnPropertyDescriptor\n\nconst getProto = Object.getPrototypeOf\n\nconst ClassDescriptorMap = new WeakMap()\n\nfunction getPropertyDescriptor(obj: any, key: PropertyKey) {\n  if (!obj) return\n  return getDescriptor(obj, key) || getPropertyDescriptor(getProto(obj), key)\n}\n\nfunction getPropertyDescriptorCache(obj: any, key: PropertyKey) {\n  const constructor = obj.constructor\n  if (constructor === Object || constructor === Array)\n    return getPropertyDescriptor(obj, key)\n  const cache = ClassDescriptorMap.get(constructor) || {}\n  const descriptor = cache[key]\n  if (descriptor) return descriptor\n  const newDesc = getPropertyDescriptor(obj, key)\n  ClassDescriptorMap.set(constructor, cache)\n  cache[key] = newDesc\n  return newDesc\n}\n\nfunction getPrototypeDescriptor(\n  target: any,\n  key: PropertyKey,\n  value: any\n): PropertyDescriptor {\n  if (!target) {\n    if (value) {\n      if (isFn(value)) {\n        return { get: value }\n      } else {\n        return value\n      }\n    }\n    return {}\n  }\n  const descriptor = getPropertyDescriptorCache(target, key)\n  if (descriptor) {\n    return descriptor\n  }\n  return {}\n}\n\nexport const computed: IComputed = createAnnotation(\n  ({ target, key, value }) => {\n    const store: IValue = {}\n\n    const proxy = {}\n\n    const context = target ? target : store\n    const property = target ? key : 'value'\n    const descriptor = getPrototypeDescriptor(target, property, value)\n\n    function compute() {\n      store.value = descriptor.get?.call(context)\n    }\n    function reaction() {\n      if (ReactionStack.indexOf(reaction) === -1) {\n        releaseBindingReactions(reaction)\n        try {\n          ReactionStack.push(reaction)\n          compute()\n        } finally {\n          ReactionStack.pop()\n        }\n      }\n    }\n    reaction._name = 'ComputedReaction'\n    reaction._scheduler = () => {\n      reaction._dirty = true\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        value: store.value,\n        type: 'set',\n      })\n    }\n    reaction._isComputed = true\n    reaction._dirty = true\n    reaction._context = context\n    reaction._property = property\n\n    function get() {\n      if (hasRunningReaction()) {\n        bindComputedReactions(reaction)\n      }\n      if (!isUntracking()) {\n        //如果允许untracked过程中收集依赖，那么永远不会存在绑定，因为_dirty已经设置为false\n        if (reaction._dirty) {\n          reaction()\n          reaction._dirty = false\n        }\n      } else {\n        compute()\n      }\n      bindTargetKeyWithCurrentReaction({\n        target: context,\n        key: property,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      try {\n        batchStart()\n        descriptor.set?.call(context, value)\n      } finally {\n        batchEnd()\n      }\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        get,\n        set,\n        enumerable: true,\n      })\n      return target\n    } else {\n      Object.defineProperty(proxy, 'value', {\n        set,\n        get,\n      })\n      buildDataTree(target, key, store)\n      ProxyRaw.set(proxy, store)\n      RawProxy.set(store, proxy)\n    }\n    return proxy\n  }\n)\n","import * as annotations from './annotations'\nimport { MakeObservableSymbol } from './environment'\nimport { createObservable } from './internals'\n\nexport function observable<T extends object>(target: T): T {\n  return createObservable(null, null, target)\n}\n\nobservable.box = annotations.box\nobservable.ref = annotations.ref\nobservable.deep = annotations.observable\nobservable.shallow = annotations.shallow\nobservable.computed = annotations.computed\nobservable[MakeObservableSymbol] = annotations.observable\n","import { isFn } from './checkers'\nimport { buildDataTree } from './tree'\nimport { observable } from './observable'\nimport { getObservableMaker } from './internals'\nimport { isObservable, isAnnotation, isSupportObservable } from './externals'\nimport { Annotations } from './types'\nimport { action } from './action'\nimport { ProxyRaw, RawProxy } from './environment'\n\nexport function define<Target extends object = any>(\n  target: Target,\n  annotations?: Annotations<Target>\n): Target {\n  if (isObservable(target)) return target\n  if (!isSupportObservable(target)) return target\n  buildDataTree(undefined, undefined, target)\n  ProxyRaw.set(target, target)\n  RawProxy.set(target, target)\n  for (const key in annotations) {\n    const annotation = annotations[key]\n    if (isAnnotation(annotation)) {\n      getObservableMaker(annotation)({\n        target,\n        key,\n      })\n    }\n  }\n  return target\n}\n\nexport function model<Target extends object = any>(target: Target): Target {\n  const annotations = Object.keys(target || {}).reduce((buf, key) => {\n    const descriptor = Object.getOwnPropertyDescriptor(target, key)\n    if (descriptor && descriptor.get) {\n      buf[key] = observable.computed\n    } else if (isFn(target[key])) {\n      buf[key] = action\n    } else {\n      buf[key] = observable\n    }\n    return buf\n  }, {})\n  return define(target, annotations)\n}\n","import {\n  batchEnd,\n  batchStart,\n  disposeBindingReactions,\n  releaseBindingReactions,\n  disposeEffects,\n  hasDepsChange,\n} from './reaction'\nimport { isFn } from './checkers'\nimport { ReactionStack } from './environment'\nimport { Reaction, IReactionOptions, Dispose } from './types'\nimport { toArray } from './array'\n\ninterface IValue {\n  currentValue?: any\n  oldValue?: any\n}\n\nexport const autorun = (tracker: Reaction, name = 'AutoRun') => {\n  const reaction: Reaction = () => {\n    if (!isFn(tracker)) return\n    if (reaction._boundary > 0) return\n    if (ReactionStack.indexOf(reaction) === -1) {\n      releaseBindingReactions(reaction)\n      try {\n        batchStart()\n        ReactionStack.push(reaction)\n        tracker()\n      } finally {\n        ReactionStack.pop()\n        reaction._boundary++\n        batchEnd()\n        reaction._boundary = 0\n        reaction._memos.cursor = 0\n        reaction._effects.cursor = 0\n      }\n    }\n  }\n  const cleanRefs = () => {\n    reaction._memos = {\n      queue: [],\n      cursor: 0,\n    }\n    reaction._effects = {\n      queue: [],\n      cursor: 0,\n    }\n  }\n  reaction._boundary = 0\n  reaction._name = name\n  cleanRefs()\n  reaction()\n  return () => {\n    disposeBindingReactions(reaction)\n    disposeEffects(reaction)\n    cleanRefs()\n  }\n}\n\nautorun.memo = <T>(callback: () => T, dependencies?: any[]): T => {\n  if (!isFn(callback)) return\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (!current || !current._memos)\n    throw new Error('autorun.memo must used in autorun function body.')\n  const deps = toArray(dependencies || [])\n  const id = current._memos.cursor++\n  const old = current._memos.queue[id]\n  if (!old || hasDepsChange(deps, old.deps)) {\n    const value = callback()\n    current._memos.queue[id] = {\n      value,\n      deps,\n    }\n    return value\n  }\n  return old.value\n}\n\nautorun.effect = (callback: () => void | Dispose, dependencies?: any[]) => {\n  if (!isFn(callback)) return\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (!current || !current._effects)\n    throw new Error('autorun.effect must used in autorun function body.')\n  const effects = current._effects\n  const deps = toArray(dependencies || [{}])\n  const id = effects.cursor++\n  const old = effects.queue[id]\n  if (!old || hasDepsChange(deps, old.deps)) {\n    Promise.resolve(0).then(() => {\n      if (current._disposed) return\n      const dispose = callback()\n      if (isFn(dispose)) {\n        effects.queue[id].dispose = dispose\n      }\n    })\n    effects.queue[id] = {\n      deps,\n    }\n  }\n}\n\nexport const reaction = <T>(\n  tracker: () => T,\n  subscriber?: (value: T, oldValue: T) => void,\n  options?: IReactionOptions<T>\n) => {\n  const realOptions = {\n    name: 'Reaction',\n    ...options,\n  }\n  const value: IValue = {}\n  const dirtyCheck = () => {\n    if (isFn(realOptions.equals))\n      return !realOptions.equals(value.oldValue, value.currentValue)\n    return value.oldValue !== value.currentValue\n  }\n\n  const fireAction = () => {\n    try {\n      //如果untrack的话，会导致用户如果在scheduler里同步调用setState影响下次React渲染的依赖收集\n      batchStart()\n      if (isFn(subscriber)) subscriber(value.currentValue, value.oldValue)\n    } finally {\n      batchEnd()\n    }\n  }\n\n  const reaction: Reaction = () => {\n    if (ReactionStack.indexOf(reaction) === -1) {\n      releaseBindingReactions(reaction)\n      try {\n        ReactionStack.push(reaction)\n        value.currentValue = tracker()\n      } finally {\n        ReactionStack.pop()\n      }\n    }\n  }\n  reaction._scheduler = (looping) => {\n    looping()\n    if (dirtyCheck()) fireAction()\n    value.oldValue = value.currentValue\n  }\n  reaction._name = realOptions.name\n  reaction()\n  value.oldValue = value.currentValue\n  if (realOptions.fireImmediately) {\n    fireAction()\n  }\n  return () => {\n    disposeBindingReactions(reaction)\n  }\n}\n","import { ReactionStack } from './environment'\nimport { isFn } from './checkers'\nimport { Reaction } from './types'\nimport {\n  batchEnd,\n  batchStart,\n  disposeBindingReactions,\n  releaseBindingReactions,\n} from './reaction'\n\nexport class Tracker {\n  private results: any\n  constructor(\n    scheduler?: (reaction: Reaction) => void,\n    name = 'TrackerReaction'\n  ) {\n    this.track._scheduler = (callback) => {\n      if (this.track._boundary === 0) this.dispose()\n      if (isFn(callback)) scheduler(callback)\n    }\n    this.track._name = name\n    this.track._boundary = 0\n  }\n\n  track: Reaction = (tracker: Reaction) => {\n    if (!isFn(tracker)) return this.results\n    if (this.track._boundary > 0) return\n    if (ReactionStack.indexOf(this.track) === -1) {\n      releaseBindingReactions(this.track)\n      try {\n        batchStart()\n        ReactionStack.push(this.track)\n        this.results = tracker()\n      } finally {\n        ReactionStack.pop()\n        this.track._boundary++\n        batchEnd()\n        this.track._boundary = 0\n      }\n    }\n    return this.results\n  }\n\n  dispose = () => {\n    disposeBindingReactions(this.track)\n  }\n}\n","import { IOperation } from './types'\nimport { ProxyRaw, ObserverListeners } from './environment'\nimport { isFn } from './checkers'\nimport { DataChange, getDataNode } from './tree'\n\nexport const observe = (\n  target: object,\n  observer?: (change: DataChange) => void,\n  deep = true\n) => {\n  const addListener = (target: any) => {\n    const raw = ProxyRaw.get(target) || target\n    const node = getDataNode(raw)\n\n    const listener = (operation: IOperation) => {\n      const targetRaw = ProxyRaw.get(operation.target) || operation.target\n      const targetNode = getDataNode(targetRaw)\n      if (deep) {\n        if (node.contains(targetNode)) {\n          observer(new DataChange(operation, targetNode))\n          return\n        }\n      }\n      if (\n        node === targetNode ||\n        (node.targetRaw === targetRaw && node.key === operation.key)\n      ) {\n        observer(new DataChange(operation, targetNode))\n      }\n    }\n\n    if (node && isFn(observer)) {\n      ObserverListeners.add(listener)\n    }\n    return () => {\n      ObserverListeners.delete(listener)\n    }\n  }\n  if (target && typeof target !== 'object')\n    throw Error(`Can not observe ${typeof target} type.`)\n  return addListener(target)\n}\n"],"names":["toString","Object","prototype","isMap","val","Map","isSet","Set","isWeakMap","WeakMap","isWeakSet","WeakSet","isFn","isArr","Array","isArray","isPlainObj","call","isCollectionType","target","isNormalType","toArray","value","ArraySet","this","forEachIndex","add","item","has","push","indexOf","delete","findIndex","splice","forEach","callback","length","batchDelete","clear","ProxyRaw","RawProxy","RawShallowProxy","RawNode","RawReactionsMap","ReactionStack","BatchCount","UntrackCount","BatchScope","DependencyCollected","PendingReactions","PendingScopeReactions","BatchEndpoints","MakeObservableSymbol","Symbol","ObserverListeners","ITERATION_KEY","getReactionsFromTargetKey","key","reactionsMap","get","reactions","map","reaction","runReactions","prevUntrackCount","i","len","_isComputed","_scheduler","isScopeBatching","isBatching","bindTargetKeyWithCurrentReaction","operation","type","current","isUntracking","bindSet","_reactionsSet","addReactionsMapToReaction","set","reactionsMap_1","addRawReactionsMap","runReactionsFromTargetKey","oldTarget","batchStart","fn","notifyObservers","_","newKey","batchEnd","releaseBindingReactions","_a","disposeBindingReactions","_disposed","_computesSet","_context","_property","_dirty","suspendComputedReactions","executePendingReactions","executeBatchEndpoints","batchScopeStart","batchScopeEnd","untrackStart","untrackEnd","hasDepsChange","newDeps","oldDeps","some","index","DataChange","node","object","oldValue","defineProperty","path","concat","DataNode","parent","getDataNode","targetRaw","isEqual","contains","raw","setDataNode","buildDataTree","currentNode","RAW_TYPE","OBSERVABLE_TYPE","hasOwnProperty","isObservable","isAnnotation","isSupportObservable","wellKnownSymbols","getOwnPropertyNames","filter","findObservable","observableObj","createObservable","patchIterator","iterator","isEntries","originalNext","next","done","instrumentations","proto","Reflect","getPrototypeOf","apply","arguments","hadKey","result","undefined","hadItems","size","cb","args","_i","wrappedCb","__spreadArray","__read","keys","values","entries","collectionHandlers","receiver","baseHandlers","observableResult","descriptor","getOwnPropertyDescriptor","writable","configurable","ownKeys","newValue","deleteProperty","createNormalProxy","shallow","proxy","Proxy","createCollectionProxy","parentRaw","createShallowProxy","createAnnotation","maker","annotation","getObservableMaker","createBoundaryFunction","start","end","boundary","results","bound","createBindFunction","context","createBoundaryAnnotation","batch","scope","endpoint","action","untracked","observable","store","enumerable","box","ref","property","getDescriptor","getProto","ClassDescriptorMap","getPropertyDescriptor","obj","getPrototypeDescriptor","constructor","cache","newDesc","getPropertyDescriptorCache","computed","compute","pop","computes","bindComputedReactions","_name","define","annotations","annotations.box","annotations.ref","deep","annotations.observable","annotations.shallow","annotations.computed","autorun","tracker","name","_boundary","_memos","cursor","_effects","cleanRefs","queue","dispose","disposeEffects","memo","dependencies","Error","deps","id","old","effect","effects","Promise","resolve","then","Tracker","scheduler","_this","track","propertyRaw","targetNode","propertyNode","reduce","buf","observer","listener","addListener","subscriber","options","realOptions","fireAction","currentValue","looping","equals","fireImmediately","visited","_toJS","res_1","res"],"mappings":"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"}